# 1 Lexical pitfalls
## 1.1 = is not ==
## 1.2 & and | are not && or ||
## 1.3 Greedy lexical analysis
## 1.4 Integer constants
## 1.5 Strings and characters

# 2 Syntactic pitfalls
## 2.1 Understanding function declarations
## 2.2 Operators don't always have the precedence you want
## 2.3 Watch those semicolons!
## 2.4 The switch statement
## 2.5 Calling functions
## 2.6 The dangling else problem

# 3 Semantic pitfalls
## 3.1 Pointers and arrays
## 3.2 Pointers are not arrays
## 3.3 Array declarations as parameters
## 3.4 Eschew synecdoche
## 3.5 Null pointers are not null strings
## 3.6 Counting and asymmetric bounds
## 3.7 Order of evaluation
## 3.8 The &&, it, and ! operators
## 3.9 Integer overflow
## 3.10 Returning a value from main

# 4 Linkage
## 4.1 What is a linker?
## 4.2 Declarations vs. definitions:
## 4.3 Name conflicts and the static modifier
## 4.4 Arguments, parameters, and return values
## 4.5 Checking external types
## 4.6 Header files

# 5 Library functions
## 5.1 getchar returns an integer
## 5.2 Updating a sequential file
## 5.3 Buffered output and memory allocation
## 5.4 Using errno for error detection
## 5.5 The signal function

# 6 The preprocessor
## 6.1 Spaces matter in macro definitions
## 6.2 Macros are not functions
## 6.3 Macros are not statements
## 6.4 Macros are not type definitions

# 7 Portability pitfalls
## 7.1 Coping with change
## 7.2 What's in a name?
## 7.3 How big is an integer?
## 7.4 Are characters signed or unsigned?
## 7.5 Shift operators
## 7.6 Memory location zero
## 7.7 How does division truncate?
## 7.8 How big is a random number?
## 7.9 Case conversion
## 7.10 Free first, then reallocate?
## 7.11 An example of portability problems

# 8 Advice and answers
## 8.1 Advice
## 8.2 Answers