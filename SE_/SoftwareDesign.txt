
服务器关闭连接：
    1. 客户端给服务器乱发数据包，即不按协议规范。比如攻击服务器。服务器解包出错，直接给这路连接关闭掉。
    2. 服务器在收数据的过程中，recv或者read函数返回0，表明对面的客户端已经先关闭连接了，这个时候服务器也没办法只好关闭连接了。
    3. 服务器在收数据的过程中，recv或者read返回-1，错误码不是EWOULDBLOCK或者EAGAIN或者EINTR，也就是说真的出错了，没办法，服务器也只能关闭连接。
    4. 长连接业务场景下，规定的时间内，客户端没有数据来往，服务器检测到了这种情况，没办法，此时服务器认为客户端已经死掉了，关闭这一路连接。

心跳包应用场景：
    1. 需要长连接的，比如即时通讯，你挂在那里一晚上没有业务数据包，网络防火墙会把你断开。那之后你就没发收到服务器消息了。
    2. 网络的中间组件故障。比如A连接B，中间需要通过C D E F G几个路由。E路由器突然故障了。因为tcp是状态机，这种网络故障没法检测到的。
       但是通过发一个心跳包，就会发现线路不通了。

    
心跳包由客户端发送：
    1. 服务器不会真正关心某个客户端是否还活着，如果某个客户端死了或者被认为死了（比如一段时间内无来往数据，但还是活着的客户端），服务器大不了直接给你关了。
        而客户端需要真正知道自己是否还活着，这关系到客户端的口粮，是否能获取到数据。
    2. 如果客户端发心跳包发现自己存在问题，要死了或者已经死了，那么客户端可以主动重连等。服务器如果发现某个客户度死了，它除了关闭客户端，其他的无能为力。
    3. 如果采取服务器心跳包也增加了服务器编码的复杂性，性价比非常低，不实用也没啥意义。

客户端发送心跳包时不立即更新lastpakegetime：
    首先发数据的时候send或者write函数只是把数据从应用程序的缓冲区搬到tcp协议栈的网卡缓冲区，数据有没有发出去是不清楚的。
    就算发出去了，服务器收到收不到又是另外一回事。

    如果服务器这次没有应答，立马再次发一个心跳包，如果服务器正常应答了，OK，还是没死。如果一段时间内还是没应答，再发一个。重复几次之后，
    心跳包的标志数量达到一定次数就认为客户端死了。接下来重连啥的就按照你自己的需求了。

    缩短心跳包时间间隔。比如原来是15秒，现在改成7.5秒，再就是7.5/2=3.75秒，1.875秒。 
    
socket keepalive 存在的前提下，心跳包存在理由：
    1. keepalive这个选项一旦设置了，会对整个协议栈的socket起作用
    2. keepalive默认时间一般是两个小时, 这个时间间隔太长了, 使用不灵活
    3. 有的时候，我们心跳包里面希望带一些需要定时更新的请求或者应答数据。这个时候keepalive也无能为力。