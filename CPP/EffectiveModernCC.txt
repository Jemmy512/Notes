Item_01: Understand template type deduction
    
    template<typename T>
    void foo(ParamType param);
    foo(expr);

    Type of T depends on both types of ParamType and expr:
    1. ParamType is a pointer or reference, but not a universal reference
    1.1 If expr's type is a reference, ignore the reference part, also const
    1.2 Then pattern-match expr's type against ParamType to determin T

        template<typename T>
        void foo(T& param);
        
        int x = 27;         // T is int, ParamType is int&
        cosnt int x = x;    // T is int, ParamType is int&
        const int &x = x;   // T is int, ParamType is int&

    2. ParamType is a universal type
    2.1 If expr is a lvalue, both T and ParamType are lvalue reference
    2.2 If expr is a rvalue, case 1 rules apply

        template<typename T>
        void foo(T&& param);    // param is now a universal reference

        int x = 27;         
        const int cx = x;
        const int &rx = x;

        foo(x);     // x is lvalue, both T and ParamType are int&
        foo(cx);    // x is lvalue, both T and ParamType are const int&
        foo(rx);    // x is lvalue, both T and ParamType are const int&
        foo(27);    // 27 is rvalue, T is int, ParamType is int&&
   
    3. ParamType is neigher a pointer nor a reference
        In this case, we are dealing with pass-by-value, and ignore expr's 
        reference-ness, constness and volatile.

        template<typename T>
        void foo(T param);    // param is now passed by value

        int x = 27;         
        const int cx = x;
        const int &rx = x;

        foo(x);     // both types of T and ParamType are int
        foo(cx);    // both types of T and ParamType are int
        foo(rx);    // both types of T and ParamType are int
        foo(27);    // both types of T and ParamType are int
        
        const char * const ptr = "Hello World";
        foo(ptr);   // T is const char *, constess of what ptr points is preversed, 
                        but not the constness of ptr itself
    
    Array Arguments:
        const char name[] = "Jemmy";
        
        template<typename T>
        void foo(T name_);
        foo(name);  // name is array, but T deduced as const char *
                    // array decay to pointer
    
        void foo(T& name_);
        foo(name);  // T is deduced const char[5] while argument type is const char (&)[5]

    Function Arguments:
        void foo(int, double);

        template<typename T>
        void f1(T param);
        void f2(T &param);

        f1(foo);    // param is deduced to ptr-to-func: void (*) (int, double)
                    // function decay to pointer to function
        f2(foo);    // param is deduced to ref-to-func: void (&) (int, double)

    Summary:
    1. During template type deduction, referenceness, constness and volatileness are ignored
    2. Array and function decay to pointers, unless they're used to initialize references

Itemm_02: Understand auto type deduction

    Auto type deduction is template type deduction

    auto x = 27;
    auto x(27); // both type is int 

    auto x = {27};
    auto x{27}; // both type is std::initializer_list<int>

    The treatment of braced initializers is the only way where auto type deduction and template type deduction differ.

    Auto in a function return type or a labmda parameter implies template type deduction not auto type deduction.
        auto foo() { return {1, 2, 3}; }    // error: cant't deduct type
        auto lambda = [&v](const auto & newValue) { v = newValue; }
        lambda({1, 2, 3});  // error: can't detect type

    /* new rules of direct initialization in C++17: 
     * For a braced-init-list with only a single element, auto deduction will deduce from that entry;
     * For a braced-init-list with more than one element, auto deduction will be ill-formed.
     */
    auto x1 = { 1, 2 };     // decltype(x1) is std::initializer_list<int>
    auto x2 = { 1, 2.0 };   // error: cannot deduce element type
    auto x3{ 1, 2 };        // error: not a single element
    auto x4 = { 3 };        // decltype(x4) is std::initializer_list<int>
    auto x5{ 3 };           // decltype(x5) is int

Item_03: Understand decltype
    
    /* C++11
     * auto befor function name has nothing to do with type deduction   
     * it indicates C++11 trailing return type syntax is being used
     */
    template<typename Container, typename Index> 
    auto authAndAccess(Container& c, Index i) -> decltype(c[i]) { // traling return type can be omit int C++14
        authenticateUser();
        return c[i];
    } 

    C++11 permits return types for sigle-statement lambdas to be deduced, C++14 extends this to both all
    lambdas and functions, including those with multiple statements.
    
    std::deque<int> d;
    authAndAccess(d, 5) = 10;
    /* compile error, return c[i] type is int&, but auto deduction will ignore reference-ness, so 
     * authAndAccess(d, 5) return type is int.
     */

    template<typename Container, typename Index>
    decltype(auto) authAndAcess(container &c, Index i) {    // now authAndAccess return is int&
        return c[i];
    }
    eg:
        int a = 20;
        const int &age = a;
        auto age0 = age;            // age0 type is int
        decltype(auto) age1 = age;  // age1 type is const int &

    Above authAndAccess can only accept lvalue container, we can support rvalue by this one:
        template<typename Container, typename Index>
        auto authAndAcess(Container &&c, Index i) { // universal reference
            return forward<Container>(c)[i];
        }

    decltype((x)) return type is reference
    eg:
        decltype(auto) foo() { int x = 0; return x; }   // return type is int
        decltype(auto) foo() { int x = 0; return (x); } // return type is int&

Item_04: Know how to view deduced type

    

Item_05: Prefer auto to explicit type declaration

    std::function<bool(const std::unique_ptr<Widget> &, const std::unique_ptr<Widget> &)>
    derefUPLess = [](const std::unique_ptr<Widget> &p1, const std::unique_ptr<Widget> &p2) { return *p1 < *p2; };

    auto derefUPLess = [](const auto &p1, const auto &p2) { return *p1 < *p2; };

    /* auto-declared variable holding a closure has the same type as the closure, 
     * and as much it uses only as many memory as the closure requires.
     * While std::function has fixed size for any signature, that's may not be adequate for the closure it's 
     * asked to store, in the case, std::function constructor allocate head memory to store the closure.
     * So, std::function object typically uses more memory that auto-declard object.
     *
     * All in all, std::function is bigger and slower than auto, and it may yield out-of-memory exception.
     */

    
    unordered_map<string, int> mp;
    for (const pair<string, int> &p : mpi;  // implicit conversion
    for (const auto &p : mp);
    /* std::map::value_type here is pair<const string, int>, compiler will convert pair<const string, int>
     * to pair<string, int> by create a temporary object which is bound to p, so take p's address will 
     * will get the temporary object's address. So it's not efficient.
     */
    
    Auto variables must be initialzed, are generally immune to type mismatches that can lead to portability or 
    efficiency problems, can ease the process of refactoring, and typically requires less typing than variables 
    with explicitly specified types.

    auto-typed variables are subject to the pitfalls described in Item_02 and 06.

Item_06: Use the explicit initializer idiom  when auto deduces undesired types

    vector<bool> features(const Widget &w);
    bool highPriority = features(w)[5]; // return type is vector<bool>::reference implicitly convert to bool 
    auto highPriority = features(w)[5]; // return type is vector<bool>::reference
    processWidget(w, highPriority);     // for auto version, undefined behavior

    auto index = static_cast<int>(d * c.size());
    Invisible” proxy types can cause auto to deduce the “wrong” type for an ini‐ tializing expression.
    The explicitly typed initializer idiom forces auto to deduce the type you want it to have.
   
Item_07: Distinguish between () and {} when creating objects

    A novel feature of braced initialization is that it prohibits implicit narrowing conversions among built-in types.

    Another noteworthy characteristic of braced initialization is its immunity to C++’s most vexing parse:
    eg:
        Widget w1(10);  // call ctor with argument 10
        Widget w2();    // most vexing parse: declares a function with return type of Widget
        Widget w3{};    // call Widget ctor with no argument
    This vexing parse is caused by the rule: A side effect of C++’s rule that anything that can be parsed as a
    declaration must be interpreted as one

    In the constructor, parentheses and braces have the same meaning as long as std::initializer_list is not involved:
        class Widget {
            public: 
                widget(int i, bool b); 
                Widget(int i, double d);
        };

        Widget w1(10, true); Widget w2{10, true};   // call first ctor
        Widget w3(10, 5.0);  Widget w4{10, 5.0};    // call second ctor

    If std::initializer_list involed, calls taking breaces initialization syntax strong prefer the overloads taking
    std::initializer_lits:
        Widget(std::initalizer_list<long double> il);        
        Widget w5{10, true}; Widget w6{10, 5.0}; // 10, true and 5.0 convert to long double
    
    Compiler's determination to match braced initializer with constructor taking std::inistailizer_list is so 
    strong, it prevails even if the best-match std::initializer_list can't be called:
        Widget (std::initializer_list<bool> il);
        Widget w7{10, 5.0}; // error: requires narrowing conversions, 10 and 5.0 should narroed converted to bool

    When using an empty set of braces to construct an object that support both default construction and 
    std::initializer_list construction, the empty set of braces means default contruction:
        class Widget {
        public:
            Widget();
            Widget(std::initializer_list<int> il);
        };
        
        Widget w1;      // default contruction
        Widget w2();    // most vexing parse! declares a function
        Widget w3{};    // -- defaul construction
        Widget w4({});  // std::initializer_list ctor with empty list
        Widget w5{{}};  // ditto

Item_08: Prefer nullptr to 0 and NULL

    The fact that template type deduction deduce the wrong types for 0 and NULL (i.e, their true types, rather than 
    their fallback meaning a representation for a nulll pointer) is the most compelling reason to use nullptr.

Item_09: Prefer alias declarations to typedefs

    Typedefs don’t support templatization, but alias declarations do.
    Alias templates avoid the “::type” suffix and, in templates, the “typename” prefix often required to refer to typedefs.
    C++14 offers alias templates for all the C++11 type traits transformations.

Item_10: Prefer scoped enums to unscoped enums

    
