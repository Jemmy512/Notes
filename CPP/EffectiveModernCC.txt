Item_01: Understand template type deduction
    
    template<typename T>
    void foo(ParamType param);
    foo(expr);

    Type of T depends on both types of ParamType and expr:
    1. ParamTye is a pointer or reference, but not a universal reference
    1.1 If expr's type is a reference, ignore the reference part, also const
    1.2 Then pattern-match expr's type against ParamType to determin T

        template<typename T>
        void foo(T& param);
        
        int x = 27;         // T is int, ParamType is int&
        cosnt int x = x;    // T is int, ParamType is int&
        const int &x = x;   // T is int, ParamType is int&

    2. ParamType is a universal type
    2.1 If expr is a lvalue reference, both T and ParamType are lvalue reference
    2.2 If expr is a rvalue reference, case 1 rules apply

        template<typename T>
        void foo(T&& param);    // param is now a universal reference

        int x = 27;         
        const int cx = x;
        const int &rx = x;

        foo(x);     // x is lvalue, both T and ParamType are int&
        foo(cx);    // x is lvalue, both T and ParamType are const int
        foo(rx);    // x is lvalue, both T and ParamType are const int&
        foo(27);    // 27 is rvalue, T is int, ParamType is int&&
   
    3. ParamType is neigher a pointer nor a reference
        In this case, we are dealing with pass-by-value, and ignore expr's 
        reference-ness, constness and volatile.

        template<typename T>
        void foo(T param);    // param is now passed by value

        int x = 27;         
        const int cx = x;
        const int &rx = x;

        foo(x);     // both types of T and ParamType are int
        foo(cx);    // both types of T and ParamType are int
        foo(rx);    // both types of T and ParamType are int
        foo(27);    // both types of T and ParamType are int
        
        const char * const ptr = "Hello World";
        foo(ptr);   // T is const char *, constess of what ptr points is preversed, 
                        but not the constness of ptr itself
