
**********************************************  STL Containers ***************************************************

Containers Ability:
    1. All containers provide value rather than reference semantics.
    2. The elements inside a container have a specific order.
    3. In general, operations are not safe in the sense that they check for every possible error.
Container Operations:
    Initialization:
        1. Initialize a container with elements of another container.
            std::make_move_iterator();
        2. Initialize a container with elements of ordinary c-style array.
            std::begin(), std::end();
        3. Initialized a container from stdin.
            std::deque<int> d{std::istream_iterator(std::cin), std::istream_iterator()};
            std::deque<int> d((std::istream_iterator(std::cin)), (std::istream_iterator()));
                // This construct is valid syntactically as either a declaration or an expression.
                // It's treated as a declaration by language rules, but extra parentheses force it to be an expession.
    Assignments and Swap:
        Iterators and Reference to elements of a container follow swapped elements, after swap they still refer
            to the elements they referred before, but in a different container.
    Size Operation:
        size(), empty(), max_size();
    Elements Access:
        All containers except vector and deques guarantee that iterators and references remain valid if other
            elements are deleted. For vector only elements before point of erase remain valid.
        If insert elements only list, forward-list and associated container guarantee that iterators and 
            references to elements remain valid.
        For vector insertion that guarantee is given but insertion don't exceed the capacity.
        For unordered list that guarantee is given for reference in general but for iterators only when no rehashing.
    Container Types:
        size_type, diff_type, val_type, reference, const_reference, iterator, const_iterator, pointer, const_pointer
Array: <array>     
    // Copy their elements into their internal static C-style array.
    namespace std {
        template <typename T, size_t N>
        class array;
    }
    
    Abilities:
    1.Initialization:
        Note array<> is the only container whose elements are default initialize when nothing passed.
        Which means for fundamental type, the initial value may undefined rather zero.
        std::array<int, 4> x; // elements of x have undfined value          ----> default-initialization
        std::array<int, x> x = {}; // ok, all elements are zero initialized ----> value-initialization
        // array<> doesn't provide a constructor for initializer list, it fulfills the requirement of aggregate.
        // An aggregate is an array or a class with no-provided constructor, no private or protected nonstatic 
            data member, no base calsses, and no virtual functions.
        // Number of elements in initializer list higher than required, its ill-formed.
        // Initializer list is the only way to initialize array during its declaration, so can't use parenthesis
            syntax to specify initial values.
            std::array<int, 5> a({1, 2, 3}); // error
            std::vector<int>   v({1, 2, 3}); // ok
    2.swap() and move semantics:
        swap assigns new value to the element that iterator, reference and pointer refer to.
        array<> can't simpley swap pointer internally, so swap has liner complexity, iterator and reference 
            don't swap containers with their elements.
        std::move() is implecity provided for array<>
    Operation:
    1.creat, copy and destroy:
        // Because class array<> is an aggreagte, those constructors are implicitly defined. The default 
            constructor default initialize the elements, which means the fundamental type value is undefined.
        array<Elem, N> c;               // Default constructor
        array<Elem, N> c(c2);           // Copy constructor
        array<Elem, N> c = c2;          // Copy constructor
        array<Elem, N> c(rv);           // Move contructor
        array<Elem, N> c = rc;          // Move constructor
        array<Elem, N> c = initist;     // Creates an array initialized with elements of initializer list
    2.Nonmodifying Operations:
        c.size();   c.empty();  c.max_size(); // maximum number
    3.Assignment Operations:
        c = c2; c = rm; c.swap(c2); swap(c, c2); c = fill(val); // assign val to each element in array c
    4.Access Operations:
        c[inx];(no range checking)  c.at(inx);(with range checking) c.front(); c.back(); (no check existence)
    5.Iterator Functions:
        being(); end(); cbegin(); cend(); rbegin(); rend(); crbegin(); crend();
        // Iterators remain valid as long as array remain valid.
Vector: <vector>
    namespace std {
        template<typname T, typname Allocator = allocator<T>>
        class vector;
    }
  1.Abilities:
    Size and Capaicity: 
        // The capacity of a vector is important for two reasons:
            1. Reallocation invalidates all reference, pointers, iterator for elements of the vector.
            2. Reallocation takes time.
        // avoid reallocation:
            v.reserve(80); // reserve memory for 80 elements
            std::vector<int> v(80);
        // To avoid internal fragmentation, implementations allocate a whole block of memory.
        // The capacity of vector never shrinks.
        // C++11 introduced a nonbinding request to shrink the capacity to fit the current number of items.
            v.shrink_to_fit(); 
                // this request is nonbinding to allow latitude for implementation-specific optimizaion. 
        // Capacity could only shrink indirectly:
            std::vector<T>(v).swap(v);
            // after swap all references, pointers, iterators invalide.
        vector<T> v;            vector<T> v(n);         v.~vector(); // detroys elems and frees memory.
        vector<T> v(v2);        vector<T> v(n, elem);
        vector<T> v = v2;       vector<T> v(beg, end);
        vector<T> v(rm);        vector<T> v(initlist);
        vector<T> v = rm;       vector<T> v = initlist;
  2. operation:
        // An explicit call to default constructor could initializes fundamental types.
        v.empty(); v.size(); v.max_size(); v.capacity(); v.reserve(); v.shrink_to_fit(); == != < >=
    Assignments
        v = v2; v = rm; v = initlist; v = assign(n, elem); v = assign(beg, end); v = assign(initlist);
        v.swap(v2); swap(v, v2);
    Access Operations:
        c[inx];(no range checking)  c.at(inx);(with range checking) c.front(); c.back(); (no check existence)
    Iterator Functions:
        // The exact type of these iterators is implementation defined.
    Insertion and Removing Elements:
        Interting and Removing happen faster when:
            1. Interting and removing at the end.
            2. The capacity is large enough on entry.
            3. Multiple elements are inserted by a single call rather than multiple calls.
        v.push_back(elem); 
        v.pop_back();               v.emplace(pos, arg...);     v.resize(num);
        v.insert(pos, elem);        v.emplace_back(arg...);     v.resize(num, elem);
        v.insert(pos, n, elem);     v.erase(pos);               v.clear();
        v.insert(pos, beg, end);    v.erase(beg, end);
        v.insert(pos, initlist);    
    Using vector as C-style Array:
        std::vector<char> v;
        v.resize(41);
        strcpy(v.data(), "hello world");
        printf("%s\n", v.data());
Deque:
    Deque manages its elements with dynamic array.
    namespace std {
        template<typename T, typename Allocator = allocator<T>>
        class deque;
    }
    1. Abilities:
        // Iterator must be smart pointer rather than ordinary pointer, because they must jump between 
            different blocks.
        // The internal structure has one more direction so the element access and iterator movement a bit slower.
        // Deques provide no support for capacity and moment of reallcation.
        // Blocks might get freed when they're no longer used, so size of deque might shrink.
    2. Operations:
        Most operations of deque are same to vector, here are some different one:   
            push_front(); emplace_front(); 
List: <list> double list
    c.unique();     c.splice(pos, c2);  c.splice(pos, c2, c2pos);   c.splice(pos, c2, c2beg, c2end);
    c.unique(op);   c.sort();   c.sort(op); c.merge(c2);    c.merge(c2, op);    c.reverse();
    // op means op() return true
Forward-List: <forward_list>
    The standard states: "It's intended that forward_list have zero spece or time overhead relative to a
        hand-written C-style singly linked list. Features that would conflict with that goal have been omitted".
    Abilities:
        1. Only provide forward iterators, not bidirectional iterators. And reverse supports are not provided also.
            Functions like reverser_iterator, rbebin(), rend(), crbegin(), crend() not provided also.
        2. The anchor of forward_list has no pointer to the last elements. So it doesn't provide functions to deal
            with the last element. Such as back(), push_back() and pop_back().
        3. For any operations that modify list in a way that elements are inserted or deleted at specific position, 
            special versions are provided. Such as _before and _after suffix member functions.
    Operations:
    1. Create, copy and destroy:
        The ability to create, copy and destroy is the same as for every sequence container.
        forward_list<Elem> l;           forward_list<Elem> l(n);            l.~forward_list();
        forward_list<Elem> l(l2);       forward_list<Elem> l(n, elem);
        forward_list<Elem> l = l2;      forward_list<Elem> l(beg, end);
        forward_list<Elem> l(rm);       forward_list<Elem> l(initlist);
        forward_list<Elem> l = rm;      forward_list<Elem> l = initlist;
    2. Nonmodifyint operations:
        l.empty(); l.max_size(); < = > // note: size() function si not provided.
    3. Assignment:
        l = l2; l = rm; l = initlist; l = assign(n, elem); l = assign(beg, end); l = assign(initlist); swap(l, l2);
    4. Access:
        front();
    5. Iterator function:
        begin(); end(); cbegin(); cend(); before_begin(); cbefore_end();
    6. Inserting and Removing:
        Gerneral hints apply:
            1. As usual when using with STL, we must ensure that arguments are valid.
            2. Inserting and removing is faster if, when working with multiple elements, you use a singal call 
                for all elements rather than multiple calls.
        l.push_front(elem);                 l.emplace_front(pos, args...);  l.reseize(num, elem);
        l.pop_front();                      l.emplace_front(args...);       l.clear();
        l.insert_after(pos, elem);          l.erase_after(pos);
        l.insert_after(pos, n, elem);       l.erase_after(beg, end);
        l.insert_after(pos, begin, end);    l.remove(val);
        l.insert_after(pos, initlist);      l.resize(num);
    7. splice and functions to change order:
        l.unique();                             l.sort();
        l.unique(op);                           l.sort(op);
        l.splice_after(pos, l2);                l.merge(l2);
        l.splice_after(pos, l2, l2pos);         l.merge(l2,op);
        l.splice_after(pos, l2, l2beg, l2end);  l.reverse();
set and multiple set:
    