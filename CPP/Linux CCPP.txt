man 
--help


Network Config:
	ifconfig
	sudo ifconfig eth0 192.168.1.212 netmask 255.255.255.0

FTP service：
	check service: lsof -i :21
	Install service: apt-get install vsftpd
SSH service：
	check service：lsof -i :22  
	Install service: apt-get install openssh-server

**********************************************  Make File  ******************************************************

1. syntax
	target: prerequisites...
		command # command line must must start with tab
	...
	
2. file name rules: Makefile / makefile / GNUmakefile

3. Five parts of makefile: 
	1. explicit rules 2. implicit rules 3. comments 4. variable defination
	5. file instruction:
		3.1 include other makefile
		3.2 specify valid parts of makefile according to cases
		3.3 define a mutil-line command
4. wildcards: *, ? [...]
	object = *.o # value of variable object is '*.o' not all .o suffix files
	objects := $(wildcard *.o) # value of variable object is all .o suffix files

5. File Search:
	1. makefile special variable:
		VPATH = <path1> : <path2> : <path3> ...
	2.makefile vpath keyword
		vapth <pattern> <directories> # vpath %.h ../header
		vpath <path> 	# clear search directories for files that match pattern <pattern>
		vpath			# clear all file search directories that have been set up
6. Mutil Target:
	bigoutput littleoutput: text.gcc
		generate text.g  -$(func args,,$@)>$@ # $:function, $@: sets of target
7. Static Mode:
	<target...> : <target-pattern> : <prereq-pattern>
		<command>
  eg:
	objects = foo.o bar.o
	all: $(objects)
	$(objects): %.o: %.c
           $(CC) -c $(CFLAGS) $< -o $@ # $<: first file of dependences, $^: all dependences, $@: sets of targets
	# $?: all dependences that newer than target file, $*: represent '%' in the target pasttern and its predecessor
8. Automatically generate dependencies
	%.d: %.c
		@set -e; rm -f $@; \
		$(CC) -M $(CPPFLAGS) $< > $@.  //-MM include std head files, -M just include dependent head files
	; \
				sed 's,$∗\.o[ :]*,\1.o $@ : ,g' < $@.
		> $@; \
				rm -f $@.

9. ; # if two next instruction dependent on previous instruction, thems should write in one line, sperate by ;
	exec:
		cd /home/hchen; pwd	# result is: pwd = /home/hchen
10 clean
	.PHONE clean
	clean:
		rm -i -f -k # -i(-ignore-errors) -k(-keep-going) -f(-force)
11. Nested Make
	subsystem:
           cd subdir && $(MAKE) # execute makefile in sudir directory may be with arguments $(MAKE)
	(un)export<variable ...>  # pass variables in current makefile to child makefile 
							  # SHELL and MAKEFLAGS varialbles always pass to child makefile
12. define instruction pakage
	define	pakageName
		command...
		command...
	enddef
13 Variable
	13.1 define
		x = $(y) # current variable can use next defined varaible
		y = z    

		x := foo # current variable can use only previous defined variables
		FOO ?= bar # if FOO is not defined its value is bar, otherwise is previous defined value
	13.2 value replacement
		foo := a.o b.o c.o
		bar := $(foo:.o=.c)	# a.c b.c c.c
		
		foo := a.o b.o c.o
		bar := $(foo:%.o=%.c) # static mode

		first_second = Hello
		a = first
		b = second
		all = $($a_$b) # all = first_sencond
	13.3 append value to value	
		objects = main.o foo.o bar.o utils.o
		objects += another.o
	13.4 override
		override <variable> = <value> # override variables defined  make instruction line
		override <variable> := <value>
		override <variable> = <value>
	13.5 multi-line variable
		define two-lines
		echo foo
		echo $(bar)
		endef




**********************************************  GDB  ************************************************************	
__LINE__, __FILE__, __func__, __DATE__, __TIME__, __STDC__, __cplusplus__

#define DEBUG

#ifdef DEBUG
 #define DBG_PRINT(fmt, args...) do {printf("[*]%s: <%s>: "fmt"\n"\
    , __FILE__, __func__, ##args); } while (FALSE);
	
//DBG_PRINT(format,...) printf("FILE: "__FILE__", LINE: %d: "format"/n", __LINE__, ##__VA_ARGS__)
#else
 #define BEG_PRINT(...) do {} while (FALSE)
#endif

core dump:
	1. suffix with pid
		echo "1" > /proc/sys/kernel/core_uses_pid  # 0 without suffix, 1 with pid suffix
	2. name form and path
		echo "/corefile/core-%e-%p-%t" > proc/sys/kernel/core_pattern
		%e(name) %p(pid) %u(uid) %g(gid) %s(signal) %t(time) %h(host name)
Gdb:
	file <program>
	kill <program>
	make source file to be debug:
		gcc -g -o ObjFileName sourceFileName
	open gdb:
		1. gdb <program>
		2. gdb <attach> <pid> 
		3. gdb <program> core
	run program: r
	run program with args: 
		set args <arg1><arg2>...
		show args
		show path
	exit gdb: quit/q
	Show content of file: list/l
		set listsize <num>
		show listsize
		list <linenum>
		list <function>
		list <filename:linenum>
		list <filename:funciton>
		list <+offset>
		list <-offset>
		list <firstLine>, <lastLine>
		list , <last>
		list + <num>
		l 10
		l main
		l hello.c:20
		l hello.c:main
	show content in GUI: focus, layout
	BreakPoint: break/b 
		b <linenum>
		b <function>
		b <funcion(type...)>
		b <filenname:linenum>
		b *<address> # memory breakpoint
		b if <conditon>
		b <linenum> thread <threadno> # if there is no threadno specified, bk will apply to all threads
		b <linenum> thread <threadno> if... # when one thread stop, all threads will be stopped by gdb
		ignore <bk no> <count>
	view breakpoint info: info breakpoint
	clean breakpoint: clear
	condition bk:
		condition <bk no> <expr>
		condition <bk no> # clear bk which num is no
	command: # when bk we can do other things
		command <bkno>
		... commnad-list...
		end
	watch point:
		watch <expr> 
		rwatch <expr> # stop program when expr is readed
		awatch <expr> # stop program when expr is read or writed
	catch point:
		catch <event> #event: throw, catch, exec, fork, vfork, load, unload
		tcatch <event> # one time catch point
		
	go: run/r
	Step into: step/s  <count>
	Step over: next/n  <count>
	run to next bk: continue/c <ignor-count>
	finish for loop: util/u <linenum>
	finish current function: finish/f
	set step-mode <on/off>
	
	step machine code: 
		setpi/si
		nexti
		display/i $pc
	function call stack: bt <n> #backtrack
	switch current stack:
        frame <n>
        up <n>
        down <n>
        info frame
        info args
        info locals
        info catch #
        info program #check the satus of current program and pid, stop reason
        info threads
        info watchpoints
        info signals
        info handle
	Methods of stopping program:
		BreakPoint, WatchPoint, CatchPoint, Signals, Thread Stops
	Signals:
		handle <signal> <keywords...>
		#keywords: nostop, stop, print, noprint, pass noignore, nopass ignore
	memory: examine/x (x/n,f,u)
		x [Address expression]
		x /[Format] [Address expression]
		x /[Length][Format] [Address expression]
	disable/enable breakpoint: 
		disable/enables breakpoint bkNum
		delete <bk no><range>
	
	view registers: info register (i r)
	view vriable:
		info local variableName
		info local file::variableName
		info local function::variable
		info registers variableName
		whatis <var> # show var type and value
		ptype <var> # show var type
	view: print/f
		x d u o t a c f
		
		set print pretty  = on/off
		$1 = {a = 100, b = 200, c = 300}
		
		print var = value # change the local variable's value
	display:
		display/<fmt> <varname>
		display/i $pc
		info display
		disalbe enable 
	jump:
		jump <linenum>
		jump <address>
		set $pc = address
	call:
		call <funname>
 	view array:
		print *<array>@<len>
		int a[10]-> p *a@10
	run shell in gdb: shell <command>
Search:
	forward-search <regexp>
	search <regexp>
	reverse-search <regexp>
source path:
		directory <dirname...> # :(unix), ;(window)
		directory # clear path info
		show directories
define own enviroment variable int GDB:
	set $<varname> = <value> # enviromet var have no type
	show convenience # view all enviroment variable
	
**********************************************  Network Programming  ********************************************
Procedure of socket:
	1. Create Soket (client and server)
		int socket(int domain, int type, int protocol);
		
		doamin: AF_INET, AF_INET6, AF_LOCAL, AF_ROUTE
		type: SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, SOCK_PACKET, SOCK_SEQPACKET
		protocol: IPPROTO_TCP, IPPROTO_UDP, IPPROTO_SCTP
	2. bind (server)
		int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
		
		struct sockaddr_in {
			sa_family_t sin_family;	// address family
			in_port_t sin_port;		// port in network byte order
			struct in_addr sin_addr;// internet address
		};
		struct in_addr {
			uint32_t s_addr;	// address in network byte order
		};
		
		#include <arpa/inet.h>
		uint32_t htonl(uint32_t hostlong);
		uint16_t htons(uint16_t hostshort);
		uint32_t ntohl(uint32_t netlong);
		uint16_t ntohs(uint16_t netshort);
		
		#include <sys/socket.h>
		#include <netinet/in.h>
		#include <arpa/inet.h>
        
		int inet_aton(const char *cp, struct in_addr *inp);
		int inet_pton(int af, const char *src, void *dst);	// convert IP from text to binary form

		in_addr_t inet_addr(const char *cp);
		in_addr_t inet_network(const char *cp);
		char *inet_ntoa(struct in_addr in);
		int inet_pton(int af, const char *src, void *dst); // "0.0.0.0" -> 0.0.0.0
		const char *inet_ntop(int af, const void *src, char *dst, socklen_t cnt); 
		struct in_addr inet_makeaddr(int net, int host);
		in_addr_t inet_lnaof(struct in_addr in);
		in_addr_t inet_netof(struct in_addr in);
		
	3. listen(sever) and connect(client)
		int listen (int sockfd, int backlog);
		int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
	4. accept (client and server)
		int accept(int sockfd, struct sockaddr* addr, socklen_t *addrlen);
	5. read and write (client and server)
		ssize_t read(int fd, void *buf, size_t count);
		ssize_t write(int fd, const void *buf, size_t count);
		
		ssize_t send(int sockfd, const *buf, size_t len, int flags);
		ssize_t recv(int sockfd, void *buf, size_t len, int flags);
		
		ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
						const struct sockaddr *dest_addr, socklen_t addrlen);
		ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, 
						struct sockaddr *stc_addr, socklen_t *addrlen);
						
		ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
		ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
		
	5. close <unistd.h>
		int close(int fd);

Components of Server:
	1. IO communication unit
		1.1 Port multiplexing
			select 1000, poll, epoll 30W
		1.2 Synchronization	
			http https 
		1.3 asynchroniztion
			signal, sigaction
		1.4 asynchronous IO
			aio_read, aio_write
	2. Data Process Unit	
		2.1 Multiple Thread	
			Thread Mutext: mutex, spin, atomic
			Thread Synchronization: PV, semaphore
			Thread Communication
		2.2 Multiple Prcesses
			IPC pip, fifo, socketpair
		2.3 Multiple Thread + Multiple Process
			Thread Pool
			Process Pool
	3. Date Storage
Two high-performance server architectures:
	1. Reactor
	2. Proactor
	
Port multiplexing:
	1. select
		#include <sys/select.h>
		#include <sys/time.h>
		int select(int maxfs1, fs_set *readset, fd_set *writeset, fd_set *exceptset, const struct timeval *timeout)
		void FD_ZERO(fd_set *fdset);
		void FD_SET(int fd, fd_set *fdset);
		void FD_CLR(int fd, fd_set *fdset);
		void FD_ISSET(int fd, fd_set *fdset);
		void FD_ZERO(fd_set *fdset); 
        struct timeval{
			long tv_sec;   //seconds
            long tv_usec;  //microseconds
		};
	2. Poll
		# include <poll.h>
		int poll( struct pollfd * fds, unsigned int nfds, int timeout);

		struct pollfd {
			int fd;         	
			short events;       // waiting event  
			short revents;      // happend event
		} ; 
		Event: POLLIN, POLLRDNORM, POLLBAND, POLLPRI, POLLOUT, POLLWRNORM,
				POLLWRBAND, POLLMSGSIGPOLL, POLLER, POLLHUP, POLLNVAL
	3. Epoll
		#include <sys/epoll.h>
		int epoll_create(int size);
		int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
			op: EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL
			struct epoll_event {
			  __uint32_t events;  /* Epoll events */
			  epoll_data_t data;  /* User data variable */
			};
			Event: EPOLLIN, EPOLLOUT, EPOLLPRI, EPOLLET, EPOLLONESHOT, EPOLLERR, EPOLLHUP
		int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
		
		#include <sys/socket.h>
		int setsockopt(int socket, int level, int option_name, const void *option_value, socklen_t option_len);
			level: SOL_SOCKET, IPPROTO_TCP
			option_name: SO_REUSEADDR, SO_KEEPLIVE, SO_LINGER
			
		#include <unistd.h>
		#include <fcntl.h>
		int fcntl(int fd, int cmd, ... /* arg */ ); // manipulate file descriptor
			cmd: F_DUPFD, F_SETFD, F_GETFL, 

Raw-socket:
	int setsockopt (int socket, int level, int optname, const void *optvalue, socklen_t optlen);  // ok:0
	int getsockopt (int sockfd, int level, int optname, void *optval, socklen_t *optlen);
	level: 	
		SOL_SOKCET: SO_BROADCASE(bool), SO_RCVTIMEO(struct timevl), SO_SNDTIMEO(struct timeval), 
			SO_REUSEADDR, SO_KEEPALIVE, SO_LINGER, 
		IPPROTO_IP: IP_HDRINCL(bool), IP_ADD_MEMBERSHIP(struct ip_mreq), IP_DROP_MEMBERSHIP, IP_MULTICAST_IF(DWORD),
			IP_MULTICAST_LOOP, IP_MULTICAST_TTL	
            
**********************************************  File System Programming  ****************************************
   
struct stat {
    dev_t   st_dev;     //Id of device containing file
    ino_t   st_ino;     // inode number
    mode_t  st_mode;    // file type and mode
    nlink_t st_nlink;   // number of hard link
    uid_t   st_uid;     // user id
    gid_t   st_git;
    dev_t   st_rdev;    // Device Id (if special file)
    off_t   st_size;    // Total size, in bytes
    blksize_t st_blksize;   // block size for filesystem I/O
    blksize_t st_blocks;    // Number of 512B blocks allocatd
    
    struct timespec st_atim;    // last access time
    struct timespec st_mtim;    // last modification time
    struct timespec st_ctim;    // last stat change  time
};

mode_t:
    S_IFMT, S_IFSOCK, S_IFLNK, S_IFREG, S_IFBLK, S_IFDIR, S_IFCHR, S_IFIO
    S_ISERG(m); S_ISDIR(m); S_ISCHR(m); S_ISBLK(m); S_ISFIFO(m); S_IFLNK(M), S_ISSOCK(m)
    S_ISUID, S_ISGID, S_IRWXU, S_IRUSR, S_IWUSR, S_IXUSR, S_IRWXG, S_IRWXO
int stat(const char *pathname, strutct stat *statbuf);
int fstat(int fd, struct stat *statbuf);
int lstat(const char *pathname, struct stat *statbuf); // pathname is symbolic link, return info about link itself
   
int mkdir(const char *pathname, mode_t mode);  
struct FTW {
    int base;   // offset of the filename
    int leve;
};
 
int nftw(const char *path, int (*fn)(const char *fpath, const struct stat *sb, int typeflag, struct FTW *ftwbuf),
          int fd_limit, int flags);
    flags: FTW_CHDIR, FTW_DEPTH, FTW_MOUNT, FTW_PHYS
    
    FTW_D, FTW_DNR, FTW_DP, FTW_F, FTW_NS, FTW_SL, FTW_SLN 
    
int posix_fadvise(int fd, off_t offset, off_t len, int advise);// predeclare an access pattern for file data
    advise: POSIX_FADV_NORMAL, *_SEQUENTIAL, *_RANDOM, *_NOREUSE, *_WILLNEDD, *_DONTNEED
int fallocate(int fd, int mode, off_t offset, off_t len); // nonportable
int posix_fallocate(int fd, int mode, off_t offset, off_t len);
    Allocating disk space:      0, FALLOC_FL_KEEP_SIZE, *_UNSHARE
    Deallocating disk space:    FALLOC_FL_PUNCH_HOLE, 
    Collapsing file space:      FALLOC_FL_COLLAPSE_RANGE
    Zeroing file spece:         FALLOC_FL_ZERO_RANGE(nonportable)
    Increasing file space:      FALLOC_FL_INSERT_RANGE
ssize_t pwrite(int fildes, const void *buf, size_t nbyte, off_t offset);;
ssize_t write(int fildes, const void *buf, size_t nbyte);    
    
**********************************************  Semaphore Programming  *******************************************
    sem_init(sem_t *sem, int pshared, unsigned int value); // Initializing initialized semaphore is undefined
    sem_open(); shm_open(); sem_close(); sem_destroy(); sem_unlink();
    int sem_post(set_t *sem);    // -pthread_kill
    sem_wait(sem_t *); sem_timewait(set_t *); sem_trywait(sem_t *, const struct timespec *abs_timeout);
    sem_getvalue(sem_t *sem, int *sval);
    sem_overview();
    signal-safety();
    
**********************************************  Signal Programming  *********************************************
Methods of Local Processes Communication:
	1. Messaging (pipeline, FIFO, message queue)
	2. Synchronization (mutex, conditional variable, read and write lock, file and wirte and lock lock, semaphore)
	3. Shared memory (anonymous and named)
	4. Remote procedure Call (Solaris gate and sun RPC)
    
checking for the existence of a process:
    wait(); semophore and exclusive file locks; IPC(pipes, FIFOs...); /proc/PID
 
Signal dispositions: Term, Ign, Core, Stop, Cont

Linux Signals are:
    Name	Number	Description
    SIGHUP	1       Hangup (POSIX)
    SIGINT	2       Terminal interrupt (ANSI)
    SIGQUIT	3       Terminal quit (POSIX)
    SIGILL	4       Illegal instruction (ANSI)
    SIGTRAP	5       Trace trap (POSIX)
    SIGIOT	6       IOT Trap (4.2 BSD)
    SIGBUS	7       BUS error (4.2 BSD)
    SIGFPE	8       Floating point exception (ANSI)
    SIGKILL	9       Kill(can't be caught or ignored) (POSIX)
    SIGUSR1	10      User defined signal 1 (POSIX)
    SIGSEGV	11      Invalid memory segment access (ANSI)
    SIGUSR2	12      User defined signal 2 (POSIX)
    SIGPIPE	13      Write on a pipe with no reader, Broken pipe (POSIX)
    SIGALRM	14      Alarm clock (POSIX)
    SIGTERM	15      Termination (ANSI)
    SIGSTKFLT	16  Stack fault
    SIGCHLD	17      Child process has stopped or exited, changed (POSIX)
    SIGCONT	18      Continue executing, if stopped (POSIX)
    SIGSTOP	19      Stop executing(can't be caught or ignored) (POSIX)
    SIGTSTP	20      Terminal stop signal (POSIX)
    SIGTTIN	21      Background process trying to read, from TTY (POSIX)
    SIGTTOU	22      Background process trying to write, to TTY (POSIX)
    SIGURG	23      Urgent condition on socket (4.2 BSD)
    SIGXCPU	24      CPU limit exceeded (4.2 BSD)
    SIGXFSZ	25      File size limit exceeded (4.2 BSD)
    SIGVTALRM       26	Virtual alarm clock (4.2 BSD)
    SIGPROF	27      Profiling alarm clock (4.2 BSD)
    SIGWINCH	28  Window size change (4.3 BSD, Sun)
    SIGIO	29      I/O now possible (4.2 BSD)
    SIGPWR	30      Power failure restart (System V)

union sigval {
    int     sival_int;  // Integer value
    void    *sival_ptr;
};
    
struct sigevent {
    int             sigev_notify;   // SIGEV_THREAD, SIGEN_NONE, SIGEN_SIGNAL, SIGEV_THREAD_ID
    void (*sigev_notify_function) (union sigval);   //        
    void            *sigev_notify_attributes;       // SIGEV_THREAD
    int             sigev_signo;
    union sigval    sigev_value;                    // Data passed with notifications   
    pid_t           sigev_notify_thread_id;         // SIGEV_THREAD_ID 
};
    
sighandler_t signal(int signum, sighandler_t handler);
    // multi-process is unspecified
    // behavior is undefined if a process ignores SIGFPE, SIGILL, SIGSEGV
    Two common design:
        1. set a global flag and exits;
        2. perform some type of cleanup and then either teriminates the process or uses a nonlocal 
            goto to unwind the stack and return control to a predetermined location in the main program;
    
sending a signal:
    raise(int sig); kill(getpid(), int sig); killpg(pid_t pgrp , int sig);
	pthread_kill(); tgkill(); sigqueue();
signal description:
	sys_siglist[SIGPIPE]; strsignal(int sig); psignal(int sig, const char *msg);
waiting for a signal to be caught:  
    sigsuspend();  pause(); // -1
syschronously accepting a signal:
    sigwaitinfo(); sigtimedwait(); sigwait();
    signalfd();
signal mask:
    pthread_sigmask(); int sigprocmask (int how, const sigset_t *restrict set, sigset_t *restrict oldset);
    how: SIG_BLOCK, SIG_UNBLOCK, SIG_SETMASK
sigset_t:
    sigemptyset(sigset_t *set);   sigaddset(sigset_t *set, int signum);  
    sigfillset(sigset_t *set);    sigdelset(sigset_t *set, int signum);
    sigismember(const sigset_t *set, int signum); // ok: 1

    sigaltstack();
sigaction:
    int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
    
    struct sigaction {
      void (*sa_handler)(int); // SIG_IGN, SIG_DFL
      void (*sa_sigaction)(int, siginfo_t *, void *);   // si_code, si_signo, si_value
      sigset_t sa_mask;
      int sa_flags;
      void (*sa_restorer)(void);
    };
    
    sa_mask: SA_NOCLDSTOP, SA_NOCLDWAIT, SA_NODEFER, SA_ONSTACK, SA_RESETHAND, SA_RESTART, SA_RESETORE, SA_SIGINFO

signaltstack():

int kill(pid_t pid , int sig ); // (> 0), (0), (-1), (< -1) 

signal handler:
    reentrant function:
        A function is one, whose effect, when called by two or more threads, is guaranted to be
        as if threads each executed the function one after the other in undefined order, 
        even if the actual execution is interleaved.
        
        use global or static data structure is nonreentrant function.
        
    async-signal-safe function:
        implementation guarantees to be safe when called form a signal handler, either it is
        reentrant or is not interruptible by a signal handler.
    tips for writing async-signal-safe functions:
        1. ensure reentrant and call only async-signal-safe function inside;
        2. block delivery of signal while executing code in main program that calls unsafe functions 
            or work with global data structures also updata by signal handler
    use erro inside the signal handler    
    global variable should be declared by using volatile:   volatile sig_atomic_t flag;
        in order to prevent compiler from performing optimizations that result in varaible being stored in register
    terminating a signal handler:
        _exit(); kill(); raise(); nonlocal goto; abort();
    
    performing a nonlocal goto from a signal handler: <setjmp.h> 
        int sigsetjmp(sigjump_buf env, int savesigs);    void siglongjmp(sigjmp_buf env, int val);
        

**********************************************  Aio Programming  ************************************************

struct aiocb {
    int             aio_fildes; // 
    volatile void   *aio_buf;
    int             aio_nbytes;
    off_t           aio_offset;
    int             aio_reqprio;    // request priority
    struct sigevent aio_sigevent;
    int             aio_lio_opcode; // LIO_READ, LIO_WRITE, LIO_NOP
};

operation:
    // simultaneous aio_read or aio_write using same aiocb yield undefined result
    // errno: EINPROGRESS, ENOSYS, EINTER, ECANCELED
    aio_read();     aio_write();    aio_fsync();   aio_error(); aio_return();
    aio_suspend();  aio_cancel();   lio_listio();

    int aio_suspend(const struct aiocb *const aiocb_list[], // don't forget const
                        int  nitems, const struct timespec *timeout); 
    // aio_suspend && lio_listio --> 0:ok, else: -1                   
    int lio_listio(int mode, struct aiocb *const aiocb_list[],
                      int nitems, struct sigevent *sevp);


**********************************************  IPC Programming  ************************************************
Unix inter-domain communication:
    Unix communicatin:
        soketpair, pipe, FIFO, signal
    System V:
        semaphore, message queue, shared memory
        
Pipe:
    int pipe(int pipefd[2]);    int pipe2(int pipefd[2], int flag);
    flag:   0, O_CLOSEXEC, O_DIRECT, O_NONBLOCK
   
popen: pipe stream to or from a process
    FILE *popen(const char *command, const char *type); // type: "r", "w","e"
    int pclose(FILE *stream);
ID, Key:
    key_t ftok(const char *pathname, int proj_id);
    key: 31-24(proj_id low 8 bits), 23-16(st_dev low 8 bits), 15-0(st_ino low 16 bits)
msg_queue:
    struct msqid_ds {
        struct ipc_perm msg_perm;
        time_t          msg_stime;
        time_t          msg_rtime;
        time_t          msg_ctime;
        unsigned long   __msg_cbytes;
        msgqnum_t       msg_qum;
        msglen_t        msg_qbytes;     // MSGMNB, MSGMNI
        pid_t           msg_lspid;
        pid_t           msg_lrpid;
    };
    struct ipc_perm {
        key_t           __key;
        uid_t           uid;
        gid_t           gid;
        uid_t           cuid;
        git_t           cgid;
        unsigned short  mode;   // permission
        unsigned short  __seq;  // sequence number
    };
    struct msgbuf{
        long mtype;     
        char mtext[1];  // msg data
    };
    struct msg_info {
        int     msgpool;// unused within kernel
        int     msgmap; // unused
        int     msgmax; // message max size  
        int     msgmnb; // queue max size
        int     msgmni; // message queues max size
        int     msgssz; // message segment size
        int     msgtql; // message max size on all queues in system
        unsigned short int msgseg;  // segment max size
    };
    creat msg queue:
        int msgget(key_t key, int msgflag);
        msgflag: IPC_CREAT|666, IPC_EXCL|666, IPC_NOWAIT|666
    control msg queue:
        int msgctl(int msgid, int cmd, struct msqid_ds *buf);
        cmd: IPC_STAT, IPC_SET, IPC_RMID, IPC_INFO, MSG_INFO, MSG_STAT
    send to msg queue:
        int msgsnd(int msgid, const void *msgp, size_t msgsz, int msgflag);
    receive from msg queue:
        ssize_t msgrcv(int msgid, void *msgp, size_t msgsz, long msgtyp, int msgflag);
        flag: MSG_NOERROR, MSG_COPY, MSG_EXCEPT, MSG_COPY, IPC_NOWAIT
        type: 0, >0, <0
        
semaphore:
    category:
        1. kernel semaphore
        2. user semaphore: POXIS, SYSTEM V
    POXIS unamed semaphore:
        int sem_init(sem_t *sem, int pshared, unsigned int value);
        int sem_getvalue(sem_t *sem, int *sval);
        int sem_wait(sem_t *sem);
        int sem_pose(sem_t *sem);
        int sem_trywait(sem_t *sem);
    POSIX named semaphore:
        sem_t *open(const char *name, int oflag, mode_t mode, int value);
            oflag: O_CREAT, O_CREATE|O_EXCL
        int sem_wait(sem_t *sem);
        int sem_pose(sem_t *sem);
        int sem_close(sem_t *sem);
        int sem_unlink(const char *name);
    SYSTEM V semaphore:
        struct semid_ds {
            struct ipc_perm sem_perm;
            struct sem      *sem_base; // ptr to first sem in array 
            ushort          sem_nsems; // num of the sem array
            time_t          sem_otime;
            time_t          sem_ctime;
            ...
        };
        struct sem {
            ushort  semval;
            short   sempid;
            ushort  semncnt;
            ushort  semzcnt;
        };
        struct sembuf {
            short   sem_num;
            short   sem_op;
            short   sem_flg;    // SEM_UNDO, IPC_NOWAIT
        };
        int semget(key_t key, int nsems, int oflag);
        int semop(int semid, struct sembuf *opsptr, size_t nops);
        int semctl(int semid, int semnum, int cmd, ../*union semun arg*/);
            union semun {
                int             val;    // cmd == SETVAL
                struct semid_ds *buf;   // cmd == IPC_SET, IPC_STAT
                ushort          *array; // cmd == SETALL, GETALL
            };
            cmd: IPC_RMID, IPC_INFO, GETALL, GETNCNT, GETPID, GETVAL 
Shared memory:
    struct shmid_dsn{
        struct ipc_perm shm_perm;
        size_t          shm_segsz;
        time_t          shm_ctime;
        time_t          shm_atime;
        time_t          shm_dtime;
        pid_t           shm_cpid;
        pid_t           shm_lpid;   
        shmatt_t        shm_nattch;
        ...
    };
    int shmget(key_t key, size_t size, int shmflag);
        shmflag: SHM_R, SHM_W
    void *shmat(int shmid, const void *shmaddr, int shmfalg);
        shmflag: SHM_EXEC, SHM_RDONLY, 0
    int shmctl(int shmid, int cmd, struct shmid_ds *buf);      
        cmd: <IPC/SHM>_STAT, IPC_SET, IPC_RMID,  SHM_LOCK, SHM_UNLOCK
    int shmdt(const char *shmaddr);
    
    
    
**********************************************  Thread Process Programming  *************************************
    fork();
    vfork();