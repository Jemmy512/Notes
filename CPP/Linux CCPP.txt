man 
--help


Network Config:
	ifconfig
	sudo ifconfig eth0 192.168.1.212 netmask 255.255.255.0

FTP service：
	check service: lsof -i :21
	Install service: apt-get install vsftpd
SSH service：
	check service：lsof -i :22  
	Install service: apt-get install openssh-server

**********************************************  Make File  *****************************************

1. syntax
	target: prerequisites...
		command # command line must must start with tab
	...
	
2. file name rules: Makefile / makefile / GNUmakefile

3. Five parts of makefile: 
	1. explicit rules 2. implicit rules 3. comments 4. variable defination
	5. file instruction:
		3.1 include other makefile
		3.2 specify valid parts of makefile according to cases
		3.3 define a mutil-line command
4. wildcards: *, ? [...]
	object = *.o # value of variable object is '*.o' not all .o suffix files
	objects := $(wildcard *.o) # value of variable object is all .o suffix files

5. File Search:
	1. makefile special variable:
		VPATH = <path1> : <path2> : <path3> ...
	2.makefile vpath keyword
		vapth <pattern> <directories> # vpath %.h ../header
		vpath <path> 	# clear search directories for files that match pattern <pattern>
		vpath			# clear all file search directories that have been set up
6. Mutil Target:
	bigoutput littleoutput: text.gcc
		generate text.g  -$(func args,,$@)>$@ # $:function, $@: sets of target
7. Static Mode:
	<target...> : <target-pattern> : <prereq-pattern>
		<command>
  eg:
	objects = foo.o bar.o
	all: $(objects)
	$(objects): %.o: %.c
           $(CC) -c $(CFLAGS) $< -o $@ # $<: sets of target dependences, $@: sets of targets
8. Automatically generate dependencies
	%.d: %.c
		@set -e; rm -f $@; \
		$(CC) -M $(CPPFLAGS) $< > $@.
		; \
				sed 's,$∗\.o[ :]*,\1.o $@ : ,g' < $@.
		> $@; \
				rm -f $@.

				
				
				
**********************************************  GDB  ***********************************************	
Gdb:
	file <program>
	kill <program>
	make source file to be debug:
		gcc -g -o ObjFileName sourceFileName
	open gdb:
		1. gdb <program>
		2. gdb <attach> <pid> 
		3. gdb <program> core
	run program: r
	run program with args: 
		set args <arg1><arg2>...
		show args
		show path
	exit gdb: quit/q
	Show content of file: list/l
		set listsize <num>
		show listsize
		list <linenum>
		list <function>
		list <filename:linenum>
		list <filename:funciton>
		list <+offset>
		list <-offset>
		list <firstLine>, <lastLine>
		list , <last>
		list + <num>
		l 10
		l main
		l hello.c:20
		l hello.c:main
	show content in GUI: focus, layout
	BreakPoint: break/b 
		b <linenum>
		b <function>
		b <funcion(type...)>
		b <filenname:linenum>
		b *<address> # memory breakpoint
		b if <conditon>
		b <linenum> thread <threadno> # if there is no threadno specified, bk will apply to all threads
		b <linenum> thread <threadno> if... # when one thread stop, all threads will be stopped by gdb
		ignore <bk no> <count>
	watch point:
		watch <expr> 
		rwatch <expr> # stop program when expr is readed
		awatch <expr> # stop program when expr is read or writed
	catch point:
		catch <event> #event: throw, catch, exec, fork, vfork, load, unload
		tcatch <event> # one time catch point
		
	go: run/r
	Step into: step/s  <count>
	Step over: next/n  <count>
	run to next bk: continue/c <ignor-count>
	finish for loop: util/u <linenum>
	finish current function: finish/f
	set step-mode <on/off>
	
	step machine code: 
		setpi/si
		nexti
		display/i $pc
	function call stack: bt <n> #backtrack
	switch current stack:
		frame <n>
		up <n>
		down <n>
		info frame
		info args
		info locals
		info catch #
		info program #check the satus of current program and pid, stop reason
		info threads
		info watchpoints
		info signals
		info handle
	Methods of stopping program:
		BreakPoint, WatchPoint, CatchPoint, Signals, Thread Stops
	Signals:
		handle <signal> <keywords...>
		#keywords: nostop, stop, print, noprint, pass noignore, nopass ignore
	memory: examine/x (x/n,f,u)
		x [Address expression]
		x /[Format] [Address expression]
		x /[Length][Format] [Address expression]
	disable/enable breakpoint: 
		disable/enables breakpoint bkNum
		delete <bk no><range>
	view breakpoint info: info breakpoint
	clean breakpoint: clear
	condition bk:
		condition <bk no> <expr>
		condition <bk no> # clear bk which num is no
	command: # when bk we can do other things
		command <bkno>
		... commnad-list...
		end
	view registers: info register (i r)
	view vriable:
		info local variableName
		info local file::variableName
		info local function::variable
		info registers variableName
		whatis <var> # show var type and value
		ptype <var> # show var type
	view: print/f
		x d u o t a c f
		
		set print pretty  = on/off
		$1 = {a = 100, b = 200, c = 300}
		
		print var = value # change the local variable's value
	display:
		display/<fmt> <varname>
		display/i $pc
		info display
		disalbe enable 
	jump:
		jump <linenum>
		jump <address>
		set $pc = address
	call:
		call <funname>
 	view array:
		print *<array>@<len>
		int a[10]-> p *a@10
	run shell in gdb: shell <command>
Search:
	forward-search <regexp>
	search <regexp>
	reverse-search <regexp>
source path:
		directory <dirname...> # :(unix), ;(window)
		directory # clear path info
		show directories
define own enviroment variable int GDB:
	set $<varname> = <value> # enviromet var have no type
	show convenience # view all enviroment variable
	

**********************************************  Network Programming  *******************************
Methods of Local Processes Communication:
	1. Messaging (pipeline, FIFO, message queue)
	2. Synchronization (mutex, conditional variable, read and write lock, file and wirte and lock lock, semaphore)
	3. Shared memory (anonymous and named)
	4. Remote procedure Call (Solaris gate and sun RPC)
	
Procedure of socket:
	1. Create Soket (client and server)
		int socket(int domain, int type, int protocol);
		
		doamin: AF_INET, AF_INET6, AF_LOCAL, AF_ROUTE
		type: SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, SOCK_PACKET, SOCK_SEQPACKET
		protocol: IPPROTO_TCP, IPPROTO_UDP, IPPROTO_SCTP
	2. bind (server)
		int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
		
		struct sockaddr_in {
			sa_family_t sin_family;	// address family
			in_port_t sim_port;		// port in network byte order
			struct in_addr sin_addr;// internet address
		};
		struct in_addr {
			uint32_t s_addr;	// address in network byte order
		};
		
		#include <arpa/inet.h>
		uint32_t htonl(uint32_t hostlong);
		uint16_t htons(uint16_t hostshort);
		uint32_t ntohl(uint32_t netlong);
		uint16_t ntohs(uint16_t netshort);
		
		#include <sys/socket.h>
		#include <netinet/in.h>
		#include <arpa/inet.h>
		int inet_aton(const char *cp, struct in_addr *inp);
		in_addr_t inet_addr(const char *cp);
		in_addr_t inet_network(const char *cp);
		char *inet_ntoa(struct in_addr in);
		struct in_addr inet_makeaddr(int net, int host);
		in_addr_t inet_lnaof(struct in_addr in);
		in_addr_t inet_netof(struct in_addr in);
		
	3. listen(sever) and connect(client)
		int listen (int sockfd, int backlog);
		int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
	4. accept (client and server)
		int accept(int sockfd, struct sockaddr* addr, socklen_t *addrlen);
	5. read and write (client and server)
		ssize_t read(int fd, void *buf, size_t count);
		ssize_t write(int fd, const void *buf, size_t count);
		
		ssize_t send(int sockfd, const *buf, size_t len, int flags);
		ssize_t recv(int sockfd, void *buf, size_t len, int flags);
		
		ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
						const struct sockaddr *dest_addr, socklen_t addrlen);
		ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, 
						struct sockaddr *stc_addr, socklen_t *addrlen);
						
		ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
		ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
		
	5. close <unistd.h>
		int close(int fd);

Components of Server:
	1. IO communication unit
		1.1 Port multiplexing
			select 1000, poll, epoll 30W
		1.2 Synchronization	
			http https 
		1.3 asynchroniztion
			signal, sigaction
		1.4 asynchronous IO
			aio_read, aio_write
	2. Data Process Unit	
		2.1 Multiple Thread	
			Thread Mutext: mutex, spin, atomic
			Thread Synchronization: PV, semaphore
			Thread Communication
		2.2 Multiple Prcesses
			IPC pip, fifo, socketpair
		2.3 Multiple Thread + Multiple Process
			Thread Pool
			Process Pool
	3. Date Storage
Two high-performance server architectures:
	1. Reactor
	2. Proactor



















