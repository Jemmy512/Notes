
Network Config:
	ifconfig
	sudo ifconfig eth0 192.168.1.212 netmask 255.255.255.0

FTP service：
	check service: lsof -i :21
	Install service: apt-get install vsftpd
SSH service：
	check service：lsof -i :22  
	Install service: apt-get install openssh-server

**********************************************  Make File  ******************************************************

1. syntax
	target: prerequisites...
		command # command line must must start with tab
	...
	
2. file name rules: Makefile / makefile / GNUmakefile

3. Five parts of makefile: 
	1. explicit rules 2. implicit rules 3. comments 4. variable defination
	5. file instruction:
		3.1 include other makefile
		3.2 specify valid parts of makefile according to cases
		3.3 define a mutil-line command
4. wildcards: *, ? [...]
	object = *.o # value of variable object is '*.o' not all .o suffix files
	objects := $(wildcard *.o) # value of variable object is all .o suffix files

5. File Search:
	1. makefile special variable:
		VPATH = <path1> : <path2> : <path3> ...
	2.makefile vpath keyword
		vapth <pattern> <directories> # vpath %.h ../header
		vpath <path> 	# clear search directories for files that match pattern <pattern>
		vpath			# clear all file search directories that have been set up
6. Mutil Target:
	bigoutput littleoutput: text.gcc
		generate text.g  -$(func args,,$@)>$@ # $:function, $@: sets of target
7. Static Mode:
	<target...> : <target-pattern> : <prereq-pattern>
		<command>
  eg:
	objects = foo.o bar.o
	all: $(objects)
	$(objects): %.o: %.c
           $(CC) -c $(CFLAGS) $< -o $@ # $<: first file of dependences, $^: all dependences, $@: sets of targets
	# $?: all dependences that newer than target file, $*: represent '%' in the target pasttern and its predecessor
8. Automatically generate dependencies
	%.d: %.c
		@set -e; rm -f $@; \
		$(CC) -M $(CPPFLAGS) $< > $@.  //-MM include std head files, -M just include dependent head files
	; \
				sed 's,$∗\.o[ :]*,\1.o $@ : ,g' < $@.
		> $@; \
				rm -f $@.

9. ; # if two next instruction dependent on previous instruction, thems should write in one line, sperate by ;
	exec:
		cd /home/hchen; pwd	# result is: pwd = /home/hchen
10 clean
	.PHONE clean
	clean:
		rm -i -f -k # -i(-ignore-errors) -k(-keep-going) -f(-force)
11. Nested Make
	subsystem:
           cd subdir && $(MAKE) # execute makefile in sudir directory may be with arguments $(MAKE)
	(un)export<variable ...>  # pass variables in current makefile to child makefile 
							  # SHELL and MAKEFLAGS varialbles always pass to child makefile
12. define instruction pakage
	define	pakageName
		command...
		command...
	enddef
13 Variable
	13.1 define
		x = $(y) # current variable can use next defined varaible
		y = z    

		x := foo # current variable can use only previous defined variables
		FOO ?= bar # if FOO is not defined its value is bar, otherwise is previous defined value
	13.2 value replacement
		foo := a.o b.o c.o
		bar := $(foo:.o=.c)	# a.c b.c c.c
		
		foo := a.o b.o c.o
		bar := $(foo:%.o=%.c) # static mode

		first_second = Hello
		a = first
		b = second
		all = $($a_$b) # all = first_sencond
	13.3 append value to value	
		objects = main.o foo.o bar.o utils.o
		objects += another.o
	13.4 override
		override <variable> = <value> # override variables defined  make instruction line
		override <variable> := <value>
		override <variable> = <value>
	13.5 multi-line variable
		define two-lines
		echo foo
		echo $(bar)
		endef




**********************************************  GDB  ************************************************************
	
__LINE__, __FILE__, __func__, __DATE__, __TIME__, __STDC__, __cplusplus__

#define DEBUG

#ifdef DEBUG
 #define DBG_PRINT(fmt, args...) do {printf("[*]%s: <%s>: "fmt"\n"\
    , __FILE__, __func__, ##args); } while (FALSE);
	
//DBG_PRINT(format,...) printf("FILE: "__FILE__", LINE: %d: "format"/n", __LINE__, ##__VA_ARGS__)
#else
 #define BEG_PRINT(...) do {} while (FALSE)
#endif

core dump:
	1. suffix with pid
		echo "1" > /proc/sys/kernel/core_uses_pid  # 0 without suffix, 1 with pid suffix
	2. name form and path
		echo "/corefile/core-%e-%p-%t" > proc/sys/kernel/core_pattern
		%e(name) %p(pid) %u(uid) %g(gid) %s(signal) %t(time) %h(host name)
Gdb:
	file <program>
	kill <program>
	make source file to be debug:
		gcc -g -o ObjFileName sourceFileName
	open gdb:
		1. gdb <program>
		2. gdb <attach> <pid> 
		3. gdb <program> core
	run program: r
	run program with args: 
		set args <arg1><arg2>...
		show args
		show path
	exit gdb: quit/q
	Show content of file: list/l
		set listsize <num>
		show listsize
		list <linenum>
		list <function>
		list <filename:linenum>
		list <filename:funciton>
		list <+offset>
		list <-offset>
		list <firstLine>, <lastLine>
		list , <last>
		list + <num>
		l 10
		l main
		l hello.c:20
		l hello.c:main
	show content in GUI: focus, layout
	BreakPoint: break/b 
		b <linenum>
		b <function>
		b <funcion(type...)>
		b <filenname:linenum>
		b *<address> # memory breakpoint
		b if <conditon>
		b <linenum> thread <threadno> # if there is no threadno specified, bk will apply to all threads
		b <linenum> thread <threadno> if... # when one thread stop, all threads will be stopped by gdb
		ignore <bk no> <count>
	view breakpoint info: info breakpoint
	clean breakpoint: clear
	condition bk:
		condition <bk no> <expr>
		condition <bk no> # clear bk which num is no
	command: # when bk we can do other things
		command <bkno>
		... commnad-list...
		end
	watch point:
		watch <expr> 
		rwatch <expr> # stop program when expr is readed
		awatch <expr> # stop program when expr is read or writed
	catch point:
		catch <event> #event: throw, catch, exec, fork, vfork, load, unload
		tcatch <event> # one time catch point
		
	go: run/r
	Step into: step/s  <count>
	Step over: next/n  <count>
	run to next bk: continue/c <ignor-count>
	finish for loop: util/u <linenum>
	finish current function: finish/f
	set step-mode <on/off>
	
	step machine code: 
		setpi/si
		nexti
		display/i $pc
	function call stack: bt <n> #backtrack
	switch current stack:
        frame <n>
        up <n>
        down <n>
        info frame
        info args
        info locals
        info catch #
        info program #check the satus of current program and pid, stop reason
        info threads
        info watchpoints
        info signals
        info handle
	Methods of stopping program:
		BreakPoint, WatchPoint, CatchPoint, Signals, Thread Stops
	Signals:
		handle <signal> <keywords...>
		#keywords: nostop, stop, print, noprint, pass noignore, nopass ignore
	memory: examine/x (x/n,f,u)
		x [Address expression]
		x /[Format] [Address expression]
		x /[Length][Format] [Address expression]
	disable/enable breakpoint: 
		disable/enables breakpoint bkNum
		delete <bk no><range>
	
	view registers: info register (i r)
	view vriable:
		info local variableName
		info local file::variableName
		info local function::variable
		info registers variableName
		whatis <var> # show var type and value
		ptype <var> # show var type
	view: print/f
		x d u o t a c f
		
		set print pretty  = on/off
		$1 = {a = 100, b = 200, c = 300}
		
		print var = value # change the local variable's value
	display:
		display/<fmt> <varname>
		display/i $pc
		info display
		disalbe enable 
	jump:
		jump <linenum>
		jump <address>
		set $pc = address
	call:
		call <funname>
 	view array:
		print *<array>@<len>
		int a[10]-> p *a@10
	run shell in gdb: shell <command>
Search:
	forward-search <regexp>
	search <regexp>
	reverse-search <regexp>
source path:
		directory <dirname...> # :(unix), ;(window)
		directory # clear path info
		show directories
define own enviroment variable int GDB:
	set $<varname> = <value> # enviromet var have no type
	show convenience # view all enviroment variable

**********************************************  File I/O ********************************************************
By convention: <unistd.h>
    0, 1, 2(<STDIN, STDOUT, STDERR>_FILENO): stands for standard input, output and error, respectively.
    Range: 0 - (OPEN_MAX - 1)
        
    #include<fcntl.h>
    int open(const char *path, int oflag, ... /*mode_t mode*/);
    int openat(int fd, const char *path , int oflag, ... /*mode_t mode*/);
        // oflag: O_RDONLY, O_WRONLY, O_RDWR, O_EXEC, O_SEARCH, O_TTY_INIT, O_SYNC, O_DSYNC, O_RSYNC
        // O_APPEND, O_CLOEXEC, O_CREAT, O_DIRECTORY, O_EXCL, O_NOCTTY, O_NOFOLLOW, O_NOBLOCK,  O_TRUNC
    int create(const char *path, mode_t mode); // 
    int close(int fd); <unistd.h> == [ open(path, O_WRONLY | O_CREATE | O_TRUNC, mode)]
    off_t lseek(int fd, off_t offset, int whence); // whence: SEEK_SET, SEEK_CUR, SEEK_END, SEEK_DATA, SEEK_HOLE
        // We should be careful to compare the return value from lseek as being equal to or not equals to -1,
        // rather than testing whether it is less than 0. Because offset is possible a negative value.
    off_t fseek(FILE *stream, long int offset, int whence) <stdio.h>
    off_t ftell(FILE *stream); <stdio.h> // return current offset
    int read(int fd, void *buf, size_t nbytes);
        // There are several cases actual bytes read less than amount requested:
        // 1. Reading from a regular file, end of the file is reached before requested number of bytes has been read.
        // 2. Reading from a terminal device. Normally, up to one line is read at a time.
        // 3. Reading from a network. Buffering with network may cause less than request amount  to be return.
        // 4. Reading from a fifo or PIPE. If fifo contain fewer bytes by requested, read return only what is available
        // 5. Reading from a record-oritend device. 
        // 6. Interrupted by a signal and partial data have been read.
Parse Command Line Option
    int getopt(int argc, char *const argvp[], const char *optstring); <unistd.h>
        // If an option followed by a colon it takes an argument, otherwise it exits by itself.
        // Encounters a invalid option, returs a question mark instead of characters
        // If an option's missing, returns a question mark; if first character of options is colon, return colon
        // Pattern -- can stop getopt processing options and return -1
        // optopt, optarg, opterr, optind
    int getopt_long(int argc, char * const argv[], const char *optstring,
           const struct option *longopts, int *longindex); <getopt.h>
        // longopts' last element must be a zero array
        struct option{              
            const char  *name;
            int         has_flag;
            int         *flag;
            int         val;
        };
Syslog:
    void openlog(const char *ident, int logopt, int facility);
    void closelog(void);
    int setlogmask(int maskpri);
    void syslog(int priority, const char *message, .../*arguments*/);
FD Duplicate:
    int dup(int fd);            // equal to fcntl(fd, F_DUPFD, 0);
    int dup2(int fd, int fd2);  // equal to close(fd2); fcntl(fd, F_DUPFD, fd2);
Data sync between kernel buffer and disk:
    void sync(void);
    int fsync(int fd);
    int fdatasync(int fd);
Aotomic Operation: <unistd.h>
    ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);
    ssize_t pwrite(int fd, const void *buf, size_t nbyte, off_t offset);
File property change:
    int fcntl(int fd, int cmd, ... /*int arg*/); <fcntl.h>
        // cmd: F_DUPFD (the new fd shares the same file table entry, new has its own FL and FD_CLOEXEC is cleared)
        // F_DUPFD_CLOEXEC, F_<GETFD, SETFD>, F_SETFL, F_GETOWN, F_SETOWN, F_GETLK, F_GETLK, F_SETLKW, F_RDLCK, F_UNLCK
        // F_GETFL{O_RDONLY, O_WRONLY, O_RDWR, O_EXEC, O_SEARCH} {O_APPEND, O_NONBLOCK, O_SYNC, O_DSYNC, O_RSYNC}
ioctl: <sys/ioctl.h>
    int ioctl(int fd, int request, ...);
/dev/fd/:
    
**********************************************  File and Directories  *******************************************
TOCTTOU: time-of-check-to-time-of-use
    This error in file system namespace generally deal with attempts to subvert file permission by tricking privileged
    program into either reducing permissions on privileged file or modifying privileged file to open up a secure hole.
    
Stata Family function: <sys/stat.h>
    int stat(const char *pathname, struct stat *buf);
    int fstat(int fd, struct stat *buf);
    int lstat(const char *pathname, struct stat *buf);  // return symbolic infomation, not referenced file
    int fstatat(int fd, consth char *pathname, struct stat *buf, int flag); // AT_SYMLINK_NOFOLLOW, AT_FDCWD
    struct stat {
        dev_t       st_dev;     // Id of device containing file nane and i-node
        ino_t       st_ino;     // inode number
        mode_t      st_mode;    // file type and mode (permission)
        nlink_t     st_nlink;   // number of hard link
        uid_t       st_uid;     // user id
        gid_t       st_git;
        dev_t       st_rdev;    // Device Id (if special file: character and block special file)
        off_t       st_size;    // Total size, in bytes (files, directories, symbolic links)
        blksize_t   st_blksize; // block size for filesystem I/O
        blksize_t   st_blocks;  // Number of 512B blocks allocatd
        
        struct timespec st_atim;    // last access time
        struct timespec st_mtim;    // last modification time
        struct timespec st_ctim;    // last stat change  time
    };
    mode_t:
        S_IFMT, S_IFSOCK, S_IFLNK, S_IFREG, S_IFBLK, S_IFDIR, S_IFCHR, S_IFIO
        S_ISERG(m); S_ISDIR(m); S_ISCHR(m); S_ISBLK(m); S_ISFIFO(m); S_IFLNK(M), S_ISSOCK(m)
        S_ISUID, S_ISGID, S_IRWXU, S_IRUSR, S_IWUSR, S_IXUSR, S_IRWXG, S_IRWXO
File Type:
    1. Regular file 2. Directory file 3. Block special file 4. Character specil file 5. FIFO 6. Socket 7. Symbolic link
    S_ISREG(st_mode) S_ISDIR() S_ISCHR() S_ISBLK() S_ISFIFO() S_ISLNK() S_ISSOCK() 
    S_TYPEISMQ(struct stat *) S_TYPEISSEM() S_TYPEISSHM()
    
    int mkdir(const char *pathname, mode_t mode);  
    int nftw(const char *path, int (*fn)(const char *fpath, const struct stat *sb, int typeflag, struct FTW *ftwbuf),
              int fd_limit, int flags);
       flags: FTW_CHDIR, FTW_DEPTH, FTW_MOUNT, FTW_PHYS, FTW_D, FTW_DNR, FTW_DP, FTW_F, FTW_NS, FTW_SL, FTW_SLN
File Access Permission:
    st_mode mask:
        S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH
    
    1. Whenever we open any type of file by name, we must have execute permission on each directory mentioned in name.
    2. The read permission determines whether we can open an existing file for reading
    3. We must have write permission for a file to specify the O_TRUNC flag in the open function
    4. We can only create/delete new file in a directory unless we have write permission and execute permission
    5. Execute permission for a file must be on if we use exec function and file also has to be a regular file.
Ownership of New Files and Directory:
    The user ID of the file is set to the effective user ID of the proces, group ID can be following rules:
        1. Can be the effective group ID of the process.
        2. Can be the group ID of the directory in which the file is being created.
access and faccessat: <unistd.h> determine accessibility based on readl use and group id
    int access(const chat *pathname, int mode); 
    int faccessat(int fd, const chatr *pathname, int mode, int flag);
    // mode: F_OK, R_OK, W_OK, X_OK; flag: AR_EACCESS
umask: <sys/stat.h>  // set and get file mode creation mask
     mode_t umask(mode_t cmask);
     // any bits that are on in the file mode creation mask are tured off in the file's mode
chmod, fchmod, fchmodat: <sys/stat.h>
    int chmod(const char *pathname, mode_t mode);
    int fchmod(int fd, mode_t mode);
    int fchmodat(int fd, const char *pathname, mode_t mode, int flag); // 
        // flag: AT_SYMLINKS_NOFOLLOW doesn't follow symbolic links
    // effective user ID of the process must be equal to owner of the file or have supersuer permissions
    // S_ISUID, S_ISGID, S_ISVTX; S_IRWXU, S_IRUSR, S_IWUSR, S_IXUSR
    // S_IRWXG, S_IRGRP, S_IWGRP, S_IXGRP; S_IRWXO, S_IROTH, S_IWOTH, S_IXOTH
    // S_ISVTX(sticky bit): only owner or superuser can rename or delete permission.
    //              Two permissions are automatically remvoed by chomd:
    // 1. Only superuser can set sticky bit of a regular file.
    // 2. If the group id of new file doesn't equal to either effective group id of the  process or one the process's
    //    supplementary group IDs and if process doesn't have superuser privileges,set-group-id bit is removed.
chown, fchown, fchownat, lchown:    <unistd.h>
    int chown(const char *pathname, uid_t owner, git_t group);
        // can't used to change ownership of symbolic link
    int fchown(int fd, uit_t owner, git_t group);
    int fchownat(int fd, const char *pathname, uit_t owner, git_t group, int flag); // AT_SYMLINK_NOFOLLOW
    int lchown(const char *pathname, uit_t owner, git_t group);
    // with _POSIX_CHOWN_RESTRICTED, you can only change the group ID of the files you own, superuser can change UID
File size:
    1. Regular file size 0 is allowed.
    2. Directory size is usually a multiple of a number, such as 16 or 512.
    3. Symbolic link size is the number of byts in filename. (Symbolic link don't contain normal c null byte)
File Truncation:    <unistd.h>
    int truncate(const char *pathname, off_t length);
    int ftruncate(int fd, off_t length);
    // if previous file size is less than length, file size will increases, a hole probably crated
File system:
    
link, linkat, unlink, unlinkat, remove: <unistd.h>
    int link(const char *existingpath, const char *newpath);
    int linkat(const efd, const char *existingpath, int nfd, const char newpath, int flag); // AT_SYMLINK_NOFOLLOW
    int unlink(const char *pathname);
    int unlinkat(int fd, const char *pathname, int flag); // AT_REMOVEDIR
    int remove(const char *pathname);
rename, renameat: <stdio.h>
    int rename(const char *oldname, const char *name);
    int renameat(int oldfd, const char *oldname, int newfd, const char *newname); // AT_FDCWD
    // 1. If oldname specifies a file, if newname is exists, it can't refer to a directory, it is remvoed, and 
            oldname renamed to newname
       2. If oldname specifies a directory, newname must refer to a directory. If newname exits, it must be empty,
            then it is removed. newname can't contain a path prefix that names oldname, because oldname cant removed.
        3. If either oldname or newname refers to a symbolic link, then the link itself is proceessed, not the file 
            to which it resolves.
        4. Can't rename dot or dot-dot.
        5. As a special case, if oldname and newname refer to the same file, the function return success and without
            changing anything.
Symbolic Links: <unistd.h>
    limitation of hard link:
        1. Hard links normally require that link and the file reside in the same file system.
        2. Only the superuser can create a hard link to a directory
    int symlink(const char *actualpath, const char *sympath);
    int symlinkat(const char *actualpath, int fd, const char *sympath);
    // actualpath and sympath need not reside in the same file system.
    ssize_t readlink(const char *pathname, char *buf, size_t bufsize);
    ssize_t readlinkat(int fd, const char *pathname, char *buf, size_t bufsize);
    // combine the action of the open, read and close, return the number of bytes placed into buf. Contents returned
        in the buf are not null terminated.
File Time:
    st_atim, st_mtim(contents change time), st_ctim(i-node change time)
    Action changes i-node:
        change access permission, change uid, change number of links
futimens, utimensat, utimes: <sys/stat.h> change the access time and modification time of a file
    int futimens(int fd, const struct timespec times[2]); // calendar times
    int utimensat(int fd, const char *path, const struct timespec times[2], int flag);
    // First element of times array contain the access time and second contains the modification time.
    //                  Timestamps can be specified in four forms:
    // 1. If times[2] Null pointer. The times are set to the current time.
    // 2. Pointer to an timespec structure array. If tv_nsec is UTIME_NOW, time set to current time, tv_sec ignored.
    // 3. Pointer to an timespec structure array. If tv_nsec is UTIME_OMIT, time unchange, tv_sec ignored.
    // 4. Pointer to an timespec structure array. If tv_nsec is not UTIME_OMIT|UTIME_NOW, timestamp is set to the value 
        specified by the corresponding tv_sec and tv_nsec fields.
mkdir, mkdirat, rmdir: <sys/stat.h> 
    int mkdir(const char *pathname, mode_t mode);
    int mkdirat(int fd, const char *pathname, mode_t mode);
    int rmdir(const char *pathname);<unistd.h>
Reading Directories: <dirent.h>
    DIR *opendir(const char *pathname);
    DIR *fdopendir(int fd);
    struct dirent *readdir(DIR *dp);
    void rewinddir(DIR *dp);
    int closedir(DIR *dp);
    long telldir(DIR *dp);
    void seekdir(DIR *dp, long loc);
    // Only kernel has permission to write to directory itself.
    // Ordering of entries within the directory is implementation dependent and usually not alphabetical.
chdir, fchdir, getcwd: <unistd.h>
    int chdir(const char *pathname);
    int fchdir(int fd);
    char *getcwd(char *buf, size_t size);
struct FTW {
    int base;   // offset of the filename
    int leve;
};
    mode_t umask(mode_t cmask); // set and get file mode creation mask
int chdir(const char *pathname);
int fchfir(int fd);

char *getcwd(char *buf, size_t size);
char *getwd(char *buf);
char *get_current_dir_name(void); 

int posix_fadvise(int fd, off_t offset, off_t len, int advise);// predeclare an access pattern for file data
    advise: POSIX_FADV_NORMAL, *_SEQUENTIAL, *_RANDOM, *_NOREUSE, *_WILLNEDD, *_DONTNEED
int fallocate(int fd, int mode, off_t offset, off_t len); // nonportable
int posix_fallocate(int fd, int mode, off_t offset, off_t len);
    Allocating disk space:      0, FALLOC_FL_KEEP_SIZE, *_UNSHARE
    Deallocating disk space:    FALLOC_FL_PUNCH_HOLE, 
    Collapsing file space:      FALLOC_FL_COLLAPSE_RANGE
    Zeroing file spece:         FALLOC_FL_ZERO_RANGE(nonportable)
    Increasing file space:      FALLOC_FL_INSERT_RANGE
ssize_t pwrite(int fildes, const void *buf, size_t nbyte, off_t offset);;
ssize_t write(int fildes, const void *buf, size_t nbyte);    

#include<sys/resource.h>
struct rlimit {
    rlim_t rlim_cur;  /* Soft limit */
    rlim_t rlim_max;  /* Hard limit (ceiling for rlim_cur) */
};
setrlimit(int resource, const struct rlimit *rlp);
getrlimit(int resourcr struct rlimit *rlp);
    RLIMIT_CORE, RLIMIT_CPU, RLIMIT_DATA, RLIMIT_FSIZE, RLIMIT_NOFILE, RLIMIT_STACK, RLIMIT_AS, RLIM_INFINITY
	
**********************************************  Network Programming  ********************************************

Procedure of socket:
	1. Create Soket (client and server)
		int socket(int domain, int type, int protocol);
		
		doamin: AF_INET, AF_INET6, AF_LOCAL, AF_ROUTE
		type: SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, SOCK_PACKET, SOCK_SEQPACKET, SOCK_NONBLOCK
		protocol: IPPROTO_TCP, IPPROTO_UDP, IPPROTO_SCTP
	2. bind (server)
		int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
		
		struct sockaddr_in {
			sa_family_t sin_family;	// address _
			in_port_t sin_port;		// port in network byte order, > 1024
			struct in_addr sin_addr;// internet address: INADDR_<ANY, BROADCASE>
		};
		struct in_addr {
			uint32_t s_addr;	// address in network byte order
		};
		
		#include <arpa/inet.h>
		uint32_t htonl(uint32_t hostlong);
		uint16_t htons(uint16_t hostshort);
		uint32_t ntohl(uint32_t netlong);
		uint16_t ntohs(uint16_t netshort);
		
		#include <sys/socket.h>
		#include <netinet/in.h>
		#include <arpa/inet.h>
        
		int inet_aton(const char *cp, struct in_addr *inp);
		int inet_pton(int af, const char *src, void *dst);	// convert IP from text to binary form

		in_addr_t       inet_addr(const char *cp);
		in_addr_t       inet_network(const char *cp);
		char           *inet_ntoa(struct in_addr in);
		int             inet_pton(int af, const char *src, void *dst); // "0.0.0.0" -> 0.0.0.0
		const char     *inet_ntop(int af, const void *src, char *dst, socklen_t len); // len: INET_ADDRSTRLEN
		struct in_addr  inet_makeaddr(int net, int host);
		in_addr_t       inet_lnaof(struct in_addr in);
		in_addr_t       inet_netof(struct in_addr in);
		
	3. listen(sever) and connect(client)
		int listen (int sockfd, int backlog);
		int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
	4. accept (client and server)
		int accept(int sockfd, struct sockaddr* addr, socklen_t *addrlen);
	5. read and write (client and server)
		ssize_t read(int fd, void *buf, size_t count);
            // The behavior of multi-thread read or write is undefined
            // 
		ssize_t write(int fd, const void *buf, size_t count);
		
            // flags: MSG_PEEK, MSG_OOB(SIGURG), MSG_WAITALL
            // flag: MSG_CONFIRM, MSG_DONTROUTE, MSG_DONTWAIT, MSG_EOF, MSG_EOR, MSG_MORE, MSG_NOSIGNAL
		ssize_t send(int sockfd, const *buf, size_t len, int flags);
            // return success doesn't mean the peer process recvices data, just means the data
            // \has been delivered to network drivers without error
            // send data out of boundary will cause send fail with errno set to EMSGSIZE
            // \with byte-stream protocol send will block until entire amount of data has been transmitted
		ssize_t recv(int sockfd, void *buf, size_t len, int flags);
            
		ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                        const struct sockaddr *dest_addr, socklen_t addrlen);
		ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, 
						struct sockaddr *stc_addr, socklen_t *addrlen);
						
		ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
		ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);
		
    5. shutdown(int socket, int how); // how: SHUT_RD, SHUT_WR, SHUT_RDWR, shutdown soket send and recv
        // In multi-threads one thread calls shutdown will affect other threads' action to the same socket
	6. close <unistd.h> int close(int fd);
        // In multi-thread one thread close socket just decrement its reference count until to 0, not affect other threads
           \action to the same socket. Once all threads call close() to the same socket, socket will close at the end.
int getsockname(int sockfd, struct sockaddr *restrict addr, socklen_t *restrict alenp); // ok: 0, error: -1
int getpeername(int sockfd, struct sockaddr *restrict addr, socklen_t *restrict alenp);
       
Raw-socket:
	int setsockopt (int socket, int level, int optname, const void *optvalue, socklen_t optlen);  // ok:0
	int getsockopt (int sockfd, int level, int optname, void *optval, socklen_t *optlen);
	level: 	
		SOL_SOKCET: SO_BROADCASE(bool), SO_RCVTIMEO(struct timeval), SO_SNDTIMEO(struct timeval), 
			SO_REUSEADDR, SO_KEEPALIVE, 
		IPPROTO_IP: IP_HDRINCL(bool), IP_ADD_MEMBERSHIP(struct ip_mreq), IP_DROP_MEMBERSHIP, IP_MULTICAST_IF(DWORD),
			IP_MULTICAST_LOOP, IP_MULTICAST_TTL	
            SO_RCVBUF(mininum 512 bytes, maximum 1048576 bytes);
            SO_BROADCASE(have no meaning for stream sockets)
            SO_KEEPALIVE(only have meaning for stream sockets)
            SO_OOBINLINE
    int sockatmark(int sockfd); 
        // return 1 when we have readched urgent data, 0 if not, -1 on error; can be safe use in the handler for SIGURG
Out-of-Band data:
    OOB data is only supported on AF_INET and AF_INET6, the data can be sent by specifying the MSG_OOB fly on send function.
    The SIOCATMARK ioctl() request determine if the read pointer is pointing to the last OOB byte.
    If multiple occurrences of OOB data are sent, the OOB marker pointes to the last OOB byte of the final OOB data occurrence.
    ISGURG donesn't indicate the actual arrival of the OOB data, but only notification that is pending.
    Reciev OOB data:
        The socket API keeps track of recieved OOB data by using OOB marker witch points to the last byte of the OOB data.
        Independent of the OOB data is recieved inline, an input operation processes data up to OOB marker, if OOB data sent.
        If SO_OOBINLINE is not set:
            if MSG_OOB is specified the data will be recieved, otherwise not. if multi-data sent, only final OOB is remebered.
        If SO_OOBINLINE is set: all OOB data sent is valid, read function must read them without specifying MSG_OOB(EINVAL).
        
    
Components of Server:
	1. IO communication unit
		1.1 Port multiplexing
			select 1000, poll, epoll 30W
		1.2 Synchronization	
			http https 
		1.3 asynchroniztion
			signal, sigaction
		1.4 asynchronous IO
			aio_read, aio_write
	2. Data Process Unit	
		2.1 Multiple Thread	
			Thread Mutext: mutex, spin, atomic
			Thread Synchronization: PV, semaphore
			Thread Communication
		2.2 Multiple Prcesses
			IPC pip, fifo, socketpair
		2.3 Multiple Thread + Multiple Process
			Thread Pool
			Process Pool
	3. Date Storage
Two high-performance server architectures:
	1. Reactor
	2. Proactor
	
Port multiplexing:
	1. select
		#include <sys/select.h>
		#include <sys/time.h>
		int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *errorfds, const struct timeval *timeout)
        // nfds is the value of max fd plus one
        // timeout and every fs_set needs clean up first and then init at each time select execute
		void FD_ZERO(fd_set *fdset);
		void FD_SET(int fd, fd_set *fdset);
		void FD_CLR(int fd, fd_set *fdset);
		void FD_ISSET(int fd, fd_set *fdset);
        struct timeval{
			long tv_sec;   //seconds
            long tv_usec;  //microseconds
		};
	2. poll #include <poll.h>
		int poll( struct pollfd *fds, unsigned int nfds, int timeout);

		struct pollfd {
			int fd;             
			short events;       // request event  
			short revents;      // return event
		} ; 
		Event: POLLIN, POLLRDNORM, POLLBAND, POLLPRI, POLLOUT, POLLWRNORM,
				POLLWRBAND, POLLMSGSIGPOLL, POLLER, POLLHUP, POLLNVAL
	3. epoll
		#include <sys/epoll.h>
		int epoll_create(int size);
		int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);
			op: EPOLL_CTL_ADD, EPOLL_CTL_MOD, EPOLL_CTL_DEL
			struct epoll_event {
                uint32_t        events; /* Epoll events */
                epoll_data_t    data;   /* User data variable */
			};
            typedef union epoll_data {
                voit        *ptr;
                int         fd;
                uint32_t    u32;
                uint64_t    u64;
            } epoll_data_t;
			Event: EPOLLIN, EPOLLOUT, EPOLLPRI, EPOLLET, EPOLLONESHOT, EPOLLERR, EPOLLHUP
		int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
		
			
		#include <unistd.h>
		#include <fcntl.h>
		int fcntl(int fd, int cmd, ... /* arg */ ); // manipulate file descriptor
			cmd: F_DUPFD, F_SETFD, F_GETFL, SIG_URG
                F_SRTOWN: if thired argument is positive it represents process ID, otherwise presents process group ID
Network configuration information:
    #include<netdb.h>
    struct hostnet *gethostent(void);
    void sethostent(int stayopen);
    void endhostent(void);
    struct hostent {
        char     *h_name;
        char    **h_aliases;
        int       h_addrtype;
        int       h_length;
        char    **h_addr_list;
        ...
    };
 
**********************************************  Signal Programming  *********************************************

Methods of Local Processes Communication:
	1. Messaging (pipeline, FIFO, message queue)
	2. Synchronization (mutex, conditional variable, read and write lock, file and wirte and lock lock, semaphore)
	3. Shared memory (anonymous and named)
	4. Remote procedure Call (Solaris gate and sun RPC)
    
checking for the existence of a process:
    wait(); semophore and exclusive file locks; IPC(pipes, FIFOs...); /proc/PID
 
Signal dispositions: Term, Ign, Core, Stop, Cont

Linux Signals are:
    Name	Number	Description
    SIGHUP	1       Hangup (POSIX)
    SIGINT	2       Terminal interrupt (ANSI)
    SIGQUIT	3       Terminal quit (POSIX)
    SIGILL	4       Illegal instruction (ANSI)
    SIGTRAP	5       Trace trap (POSIX)
    SIGIOT	6       IOT Trap (4.2 BSD)
    SIGBUS	7       BUS error (4.2 BSD)
    SIGFPE	8       Floating point exception (ANSI)
    SIGKILL	9       Kill(can't be caught or ignored) (POSIX)
    SIGUSR1	10      User defined signal 1 (POSIX)
    SIGSEGV	11      Invalid memory segment access (ANSI)
    SIGUSR2	12      User defined signal 2 (POSIX)
    SIGPIPE	13      Write on a pipe with no reader, Broken pipe (POSIX)
    SIGALRM	14      Alarm clock (POSIX)
    SIGTERM	15      Termination (ANSI)
    SIGSTKFLT	16  Stack fault
    SIGCHLD	17      Child process has stopped or exited, changed (POSIX)
    SIGCONT	18      Continue executing, if stopped (POSIX)
    SIGSTOP	19      Stop executing(can't be caught or ignored) (POSIX)
    SIGTSTP	20      Terminal stop signal (POSIX)
    SIGTTIN	21      Background process trying to read, from TTY (POSIX)
    SIGTTOU	22      Background process trying to write, to TTY (POSIX)
    SIGURG	23      Urgent condition on socket (4.2 BSD)
    SIGXCPU	24      CPU limit exceeded (4.2 BSD)
    SIGXFSZ	25      File size limit exceeded (4.2 BSD)
    SIGVTALRM       26	Virtual alarm clock (4.2 BSD)
    SIGPROF	27      Profiling alarm clock (4.2 BSD)
    SIGWINCH	28  Window size change (4.3 BSD, Sun)
    SIGIO	29      I/O now possible (4.2 BSD)
    SIGPWR	30      Power failure restart (System V)

union sigval {
    int     sival_int;  // Integer value
    void    *sival_ptr;
};
    
struct sigevent {
    int             sigev_notify;   // SIGEV_THREAD, SIGEN_NONE, SIGEN_SIGNAL, SIGEV_THREAD_ID
    void (*sigev_notify_function) (union sigval);   //        
    void            *sigev_notify_attributes;       // SIGEV_THREAD
    int             sigev_signo;
    union sigval    sigev_value;                    // Data passed with notifications   
    pid_t           sigev_notify_thread_id;         // SIGEV_THREAD_ID 
};
    
sighandler_t signal(int signum, sighandler_t handler);
    // multi-process is unspecified
    // behavior is undefined if a process ignores SIGFPE, SIGILL, SIGSEGV
    Two common design:
        1. set a global flag and exits;
        2. perform some type of cleanup and then either teriminates the process or uses a nonlocal 
            goto to unwind the stack and return control to a predetermined location in the main program;
    
sending a signal:
    raise(int sig); kill(getpid(), int sig); killpg(pid_t pgrp , int sig);
	pthread_kill(); tgkill(); sigqueue();
signal description:
	sys_siglist[SIGPIPE]; strsignal(int sig); psignal(int sig, const char *msg);
waiting for a signal to be caught:  
    sigsuspend();  pause(); // -1
syschronously accepting a signal:
    sigwaitinfo(); sigtimedwait(); sigwait();
    signalfd();
signal mask:
    pthread_sigmask(); int sigprocmask (int how, const sigset_t *restrict set, sigset_t *restrict oldset);
    how: SIG_BLOCK, SIG_UNBLOCK, SIG_SETMASK
sigset_t:
    sigemptyset(sigset_t *set);   sigaddset(sigset_t *set, int signum);  
    sigfillset(sigset_t *set);    sigdelset(sigset_t *set, int signum);
    sigismember(const sigset_t *set, int signum); // ok: 1

    sigaltstack();
sigaction:
    int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact);
    
    struct sigaction {
      void (*sa_handler)(int); // SIG_IGN, SIG_DFL
      void (*sa_sigaction)(int, siginfo_t *, void *);   // si_code, si_signo, si_value
      sigset_t sa_mask;
      int sa_flags;
      void (*sa_restorer)(void);
    };
    
    sa_mask: SA_NOCLDSTOP, SA_NOCLDWAIT, SA_NODEFER, SA_ONSTACK, SA_RESETHAND, SA_RESTART, SA_RESETORE, SA_SIGINFO

signaltstack():

int kill(pid_t pid , int sig ); // (> 0), (0), (-1), (< -1) 

signal handler:
    reentrant function:
        A function is one, whose effect, when called by two or more threads, is guaranted to be
        as if threads each executed the function one after the other in undefined order, 
        even if the actual execution is interleaved.
        
        use global or static data structure is nonreentrant function.
        
    async-signal-safe function:
        implementation guarantees to be safe when called form a signal handler, either it is
        reentrant or is not interruptible by a signal handler.
    tips for writing async-signal-safe functions:
        1. ensure reentrant and call only async-signal-safe function inside;
        2. block delivery of signal while executing code in main program that calls unsafe functions 
            or work with global data structures also updata by signal handler
    use erro inside the signal handler    
    global variable should be declared by using volatile:   volatile sig_atomic_t flag;
        in order to prevent compiler from performing optimizations that result in varaible being stored in register
    terminating a signal handler:
        _exit(); kill(); raise(); nonlocal goto; abort();
    
    performing a nonlocal goto from a signal handler: <setjmp.h> 
        int sigsetjmp(sigjump_buf env, int savesigs);    void siglongjmp(sigjmp_buf env, int val);
        

**********************************************  Aio Programming  ************************************************

struct aiocb {
    int             aio_fildes; // 
    volatile void   *aio_buf;
    int             aio_nbytes;
    off_t           aio_offset;
    int             aio_reqprio;    // request priority
    struct sigevent aio_sigevent;
    int             aio_lio_opcode; // LIO_READ, LIO_WRITE, LIO_NOP
};

operation:
    // simultaneous aio_read or aio_write using same aiocb yield undefined result
    // errno: EINPROGRESS, ENOSYS, EINTER, ECANCELED
    aio_read();     aio_write();    aio_fsync();   aio_error(); aio_return();
    aio_suspend();  aio_cancel();   lio_listio();

    int aio_suspend(const struct aiocb *const aiocb_list[], // don't forget const
                        int  nitems, const struct timespec *timeout); 
    // aio_suspend && lio_listio --> 0:ok, else: -1                   
    int lio_listio(int mode, struct aiocb *const aiocb_list[],
                      int nitems, struct sigevent *sevp);


**********************************************  IPC Programming  ************************************************
Unix inter-domain communication:
    Unix communicatin:
        soketpair, pipe(PIPE_BUF), FIFO, signal
    System V:
        semaphore, message queue, shared memory
Unix outer-domain communication:
    sockets, STREAMS
Advantages and Disabvantages of XSI IPC:
    1. They are systemwide have no reference count, once created they'll exite unless deleted explicitly
    2. They are not known by names in the file system
Pipe: PIPE_BUF
    int pipe(int pipefd[2]);    int pipe2(int pipefd[2], int flag);
    flag:   0, O_CLOSEXEC, O_DIRECT, O_NONBLOCK
    // when last process referred to it terminates, the pipe is completely removed. 
FIFO:
    mkfifo(const char *path, mode_t mode);              // absolute path, mode same to open
    mkfifoat(int fd, const char *path, mode_t mode);    // path relative to the directory of fd
    // Once created, FIFO file exites in the file system
    // without O_NONBLOCK: read block untill other process write, the same to write;
    // O_NONBLOCK: read return immediately if no write, but write return -1 with errno  ENXIO if no read
    // As with pipe if write to a FIFO without reader SIGPIPE is generated
    // When last process referred to it terminates, the FIFO name remains in system, but any data removed. 
popen: pipe stream to or from a process
    FILE *popen(const char *command, const char *type); // type: "r", "w","e"
    int pclose(FILE *stream);
Identifiers and Keys:
    key_t ftok(const char *pathname, int proj_id);
    key: 31-24(proj_id low 8 bits), 23-16(st_dev low 8 bits), 15-0(st_ino low 16 bits)
msg_queue: a linked list of messages
    struct msqid_ds {
        struct ipc_perm msg_perm;
        time_t          msg_stime;
        time_t          msg_rtime;
        time_t          msg_ctime;
        unsigned long   __msg_cbytes;
        msgqnum_t       msg_qum;
        msglen_t        msg_qbytes;     // MSGMNB, MSGMNI
        pid_t           msg_lspid;
        pid_t           msg_lrpid;
    };
    struct ipc_perm {
        key_t           __key;
        uid_t           uid;
        gid_t           gid;
        uid_t           cuid;
        git_t           cgid;
        unsigned short  mode;   // permission
        unsigned short  __seq;  // sequence number
    };
    struct msgbuf{
        long mtype;     // who     
        char mtext[1];  // msg data
    };
    struct msg_info {
        int     msgpool;    // kibibytes of buffer pool, hold msg data
        int     msgmap;     // Maximun num of entries in msg map
        int     msgmax;     // Single message max size  
        int     msgmnb;     // queue max size
        int     msgmni;     // message queues max num
        int     msgssz;     // message segment size
        int     msgtql;     // message max size on all queues in system
        unsigned short int msgseg;  // segment max size
    };
    int msgget(key_t key, int msgflag); // open or creat a new one
        msgflag: IPC_CREAT|666, IPC_EXCL|666, IPC_NOWAIT|666
    int msgctl(int msgid, int cmd, struct msqid_ds *buf);
        cmd: IPC_STAT, IPC_SET, IPC_RMID, IPC_INFO, MSG_INFO, MSG_STAT
    int msgsnd(int msgid, const void *msgbuf, size_t msgsz, int msgflag);
    ssize_t msgrcv(int msgid, void *msgbuf, size_t msgsz, long msgtyp, int msgflag);
        flag: MSG_NOERROR, MSG_COPY, MSG_EXCEPT, MSG_COPY, IPC_NOWAIT
        type: 0, >0, <0(the first msg whose type is the lowest value less than or euqal to absolute value of type)
        
semaphore: is a counter used to provide access to the shared object for multiple process
    category:
        1. kernel semaphore
        2. user semaphore: POXIS, SYSTEM V
    POXIS unamed semaphore:
        int sem_init(sem_t *sem, int pshared, unsigned int value);
        // pshard: zero[shared between threads within process], non-zero[shared between processes]
        int sem_getvalue(sem_t *sem, int *sval);
        int sem_wait(sem_t *sem);
        int sem_post(sem_t *sem);
        int sem_trywait(sem_t *sem);
    POSIX named semaphore:
        sem_t *open(const char *name, int oflag, mode_t mode, int value);
            oflag: O_CREAT, O_CREATE|O_EXCL
        int sem_wait(sem_t *sem);
        int sem_post(sem_t *sem);
        int sem_close(sem_t *sem); // system will auto close if forget call
        int sem_unlink(const char *name); // destroy
    SYSTEM V semaphore:
        struct semid_ds {
            struct ipc_perm sem_perm;
            struct sem      *sem_base; // ptr to first sem in array 
            ushort          sem_nsems; // num of the sem array
            time_t          sem_otime;
            time_t          sem_ctime;
            ...
        };
        struct sem {
            ushort  semval;
            short   sempid;
            ushort  semncnt;
            ushort  semzcnt;
            ...
        };
        struct sembuf {
            short   sem_num;
            short   sem_op;
            short   sem_flg;    // SEM_UNDO, IPC_NOWAIT
        };
        int semget(key_t key, int nsems, int oflag);
        int semop(int semid, struct sembuf *opsptr, size_t nops);
        int semctl(int semid, int semnum, int cmd, ../*union semun arg*/);
            union semun {
                int             val;    // cmd == SETVAL
                struct semid_ds *buf;   // cmd == IPC_SET, IPC_STAT
                ushort          *array; // cmd == SETALL, GETALL
            };
            cmd: IPC_RMID, IPC_INFO, GETALL, GETNCNT, GETPID, GETVAL 
Shared memory: (fastest IPC)
    struct shmid_ds{
        struct ipc_perm shm_perm;
        size_t          shm_segsz; // round up to system multiple page sizse
        time_t          shm_ctime;
        time_t          shm_atime;
        time_t          shm_dtime;
        pid_t           shm_cpid;
        pid_t           shm_lpid;   
        shmatt_t        shm_nattch;
        ...
    };
    int shmget(key_t key, size_t size, int shmflag);
        shmflag: SHM_R, SHM_W, 0
    void *shmat(int shmid, const void *shmaddr, int shmfalg); // return addr of the shm in the process addr space
        shmflag: SHM_EXEC, SHM_RDONLY, 0, SHM_RND
    int shmctl(int shmid, int cmd, struct shmid_ds *buf);      
        cmd: <IPC/SHM>_STAT, IPC_SET, IPC_RMID,  SHM_LOCK, SHM_UNLOCK
    int shmdt(const char *shmaddr); // shm remains in existence untill call shmctl with IPC_RMID flag
    
Summary:    
   Learn pipe and FIFOs avoid using message queue and semaphore, Full-duplex pipes and record locking should be 
   considered instead as they are far simpler. Shared memory still has its use.
    
**********************************************  Thread Process Programming  *************************************

Results of different order of parent and child process exit:
    1. parent exit before child process: child process becomes orphan process ,init process take over it.
    2. parent exit after child without call wait or waitpid, child becomes zombie process.
    3. parent exit after child with call wait, both parent and child exit normally. 
Handle Zombie process:
    1. When child exit it will send SIGCHLD to parent, parent can call wait in SIGCHLD's handler to terminate  zombie
        while ((pid = waitpid(-1, &stat, WNOHANG)) >0)  printf("child %d terminated.\n", pid);
    2. fork twice.
    3. Ignore the SIGCHLD signal.
Enviroment List: <stdlib.h>
    Global variable: environ;
    opt: getenv(const char *name), putenv(char *string);
Consists of Program:
                    |---------------------------------------------------------------------------------
                    |                               |
    high  address   |                               | command-line arguments and environment variables
                    |                               |
                    |-------------------------------|------------------------------------------------- 0xC0000000
                    |   stack                       | automatic variable, function called  info
                    |- - - - - - - - - - - - - - - -| - - - - - - - - - - - - - - - -  
                    |                               |
                    |                               | 
                    |                               |
                    |- - - - - - - - - - - - - - - -| - - - - - - - - - - - - - - - -
                    |   heap                        | dynamic memeory allocation
                    |-------------------------------|--------------------------------
                    |   uninitialized data          | initialized to zero by exex
                    |-------------------------------|-------------------------------------------------------------
                    |   initialized data (bss)      |
                    |-------------------------------|--------- read from program file by exec
                    |      Text                     | (machine instructions, sharable, read only)
    low addresss    |-------------------------------|-------------------------------------------------- 0x08048000
    notes:
        Only initialized data and text segment are stored in the program file on disk
Memory Allocation: <stdlib.h>
    Implemented with sbrk() system call.
    Freed space is not returned to the kernel, instead, it's kept in the malloc pool and can be use for next call.
    Writing past of the end or before the begining of a allocated block is fatal.
    
Process Enviroment:
    Exit Function:
        _exit(...), _Exit(...) // return to the kernel immediately
        exit(...) // performs certain cleanup processing then returns to kernel
        ptread_exit();
        returns of the last thread from its start routine
        response of the last thread to the cancellation request
        int atexit(void *(func)(void)); // call on registered func in reverse order and as many times as registered
    fork(); // PID, memory locks, record locks, CPU time counter, pending signals, semaphore adjustments, async I/O
        // child process copys parent's data, head and stack but shares text segment and file descriptors.
        // There are two ways to handling descriptors after fork:
           1. Parent waits fo child to complete.
           2. Both parent and child go their way(close descriptors don't need, respectively) 
    pid_t wait(int *stat_loc);  
        WIFEXITED(sta)--WEXITSTATUS()   WIFSIGNALED()-WTERMSIG()    WIFSTOPED()--WSTOPSIG() WIFCONTINUED(sta)
        // return immediatelly with terminate status if one child is zombie.
    pid_t waitpid(pid_t pid, int *stat_loc, int options); // options: WCONTINUED, WNOHANG, WUNTRACED
        // pid > 0; wait the process whose process ID equals pid
        // pid == 0; wait the process whose process group ID equals calling process group ID
        // pid == -1; wait for any process
        // pid < -1; wait the process whose process group ID equals absolute value of pid
Process Shceduling: <unistd.h>
    nice value range: 0 - 2 * NZERO - 1
    modify priority: int nice(incr); // new nice value - NZERO if ok,-1 on error
    priority: <sys/resource.h>
        int getpriority(int which, id_t who);  
            // which: PRIO_PROCESS, PRIO_PGRP, PRIO_USER
            // Return: nice value between -NZERO and NZERO - 1 if ok, -1 on error
        int setpriority(int which, id_t who, int value);
            // The value is added to NZERO and this becomes new nice value
            // Return: 0 if ok, -1 on error
Process Time: <sys/times.h>
    struct tms {
        clock_t tms_utime;  // user CPU time
        clock_t tms_stime;  // system CPU time
        clock_t tms_cutime; // user CPU time, terminated children
        clock_t tms_cstime; // system CPU time, terminated children
    };
    clock_t times(struct tms *buf); // return wall clock time
    
Process exit functions:
    Five normal terminations:
        1. Executing return from the main function.
        2. Executing return from the start routine of the last thread in the process.
        3. Calling the exit(...) function.
        4. Calling the _exit(...), _Exit(...) function.
        5. Calling the pthread_exit(...) from the last thread in the process.
    Three abnormal terminations:
        1. Calling the abort(...) function. SIGABRT will generate.
        2. When process receive certain signals.
        3. The last thread responds to the cancellation request.
    Whenever a process terminates, either normally or abnormally, SIGCHLD will send to parent.
pthread:
    pthread_creat(pthread_t *thread, const pthread_attr_t *attr, void *(*start_rountin)(void *), void *arg);
        // inherits a copy of the creating thread's signal mask; pending signal is empty; don't inherit singal stack.
        // The order of executing between child and parent process depends on the scheduling algorithm used by kernel.
    pthread_join(pthread_t thread, void **retval);
    pthread_exit(void *retval);
    pthread_detach(pthread_t thread);
        pthread_attr_setdetachstate(pthread_att_t *attr, int detachstate); // PTHREAD_CREATE_<DETACHED, JOINABLE>
        pthread_attr_getdetachstate(const pthread_attr_t *attr, int *detachstate); //
    pthread_cancel(pthread_t); //re-acquire mutex before acting cancle and ensure it not consume any condtion signal
        pthread_setcancelstate(int state, int *oldstate); // PTHREAD_CANCEL_ENABLE, PTHREAD_CANEL_DISABLE
        pthread_setcanceltype(int type, int *oldtype);  // PTREAD_CANCEL_<ASYNCHRONOUS, DEFERRED>
        pthread_testcancel(void); // create a cancellation point
        pthread_cleanup_push(void (*routine)(void *), void *arg);
        pthread_cleanup_pop (int execute);
    pthread_sigmask(int how, const sigset_t *set, sigset_t *oldset);
    atexit(void (*function)(void));
process completion status:
    int WIFEXITED(int)-WEXITSTATUS, WIFSIGNALED-WTERMSIG, WCOREDUMP, WIFSTOPED, WSTOPSIG
pthread_attr:
    typedef struct {
        int     detachstate;// PTHREAD_CREATE_<JOINABLE, DETACHED>, td ID, rsc can be reused; join not reuse
        int     schedpolicy;    // SCHED_<FIFO,RR,OTHER>,determine which thread to proceed not the ordering rule    
        int     inheritsched;
        struct sched_param  schedparam;
        int     scope;          // SCOPE_SYSTEM, SCOPT_PROCESS
        size_t  guardsize; // ignored if stackaddr is set
        int     stackaddr_set;
        void *  stackaddr;  // PTHREAD_STACK_SIZE
        size_t  stacksize; // with JOINABLE attr, can't free untill pthread_join() called.
    }pthread_attr_t;
    pthread_attr_init(struct pthread_attr_t *attr);
        scope           PTHREAD_SCOPE_PROCESS
        detachstate     PTTHREAD_CREATE_JOINABLE
        stackaddr       NULL
        stacksize       1M
        inheritsched    PTHREAD_INHERIT_SCHED
        schedpolicy     SCHED_OTHER
    pthread_attr_destroy(pthread_attr_t *attr);
    pthread_attr_setdetachstate(pthread_attr_t *attr, int state);
    pthread_attr_getdetachstate(pthread_attr_t *attr, int *state);
    pthread_attr_setstacksize(pthread_attr_t *attr, size_t size); // PTHREAD_STACK_MIN
    pthread_attr_getstacksize(pthread_attr_t *attr, size_t *size); // get mim stack size
    pthread_attr_setguardsize(pthread_attr_t *attr, size_t size); // 0[no guard], round up to multiple PAGESIZE
    pthread_attr_getguardsize(pthread_attr_t *attr, size_t *size);
pthread_key:
    pthread_key_create(pthread_key_t *key, void (*destructor)(void *));
    pthread_key_delete(pthread_key_t key);
    pthread_setspecific(pthread_key_t key, const void *pointer);
    void *pthread_getspecific(pthread_key_t key);
pthread_mutex:
    pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);    
    pthread_mutex_t lock = PTHREAD_MUTEXT_INITIALIZER;
    pthread_mutex_destroy(pthread_mutex_t *mutex);
    pthread_mutex_lock(pthread_mutex_t *mutex);
    phtread_mutex_trylock(pthread_mutex_t *mutex);
    phtread_mutex_unlock(phtread_mutex_t *mutex);
phtread_cond:
    pthread_cond_init(pthread_cond_t *cond, const pthread_condattr_t *attr);
    pthread_cond_t cond = PTHREAD_COND_INITIALIZER;
    pthread_cond_destroy(pthread_cond_t *cond);
    pthread_cond_signal(pthread_cond_t *cond);
    pthread_cond_broadcast(pthread_cond_t *cond);
    pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex); // Boolean predicate
    pthread_cond_timewait(pthread_cond_t *cond, pthread_mutex_t *mutex); // cancelation point
pthread_rwlock:
    pthread_rwlock_init(pthread_rwlock_t *lock, const pthread_rwlockattr_t *attr);
    pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
    pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
    pthread_rwlock_tryrdlock(phtread_rwlock_t *rwlock);
    pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
    pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
    pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
    pthread_rwlock_timed***(...);
pthread asynchronous:
    pthread_kill(pthread_t thread, int sig); // 0: test the existence of thread
    phread_sigmask(int how, const sigset_t *set, sigset_t *oldset); // sigprocmaks(...);
        how: SIG_BLOCK, SIG_UNBLOCK, SIG_SETMASK
     
xinetd:
    
 
**********************************************  HTTPS Programming   *********************************************

SSL:
    Consists of two layers of protocol:
        High-level protocol: 
            SSL HandShake Protocol: Algorithm negotiation, identity authentication, private key determination
                categories: Full HandShake, Resume session HandShake, <Server, Client> Re-nogotiation HandShake
            Change Cipher Spec Protocol
            AlertProtocol
        Low-level protocol: 
            SSL Record Protocol(certificate information, test data is tampered or not)
                | type(1 byte) | version(2 byte) | length(2)byte | data | HMAC | Filling 0 | Fill length | 
Connection Process: https://www.cnblogs.com/yuweifeng/p/5641280.html
    1. init
        SSL_library_init();
        OpenSSL_add_all_algorithms();
        SSL_load_error_strings(); // void ERR_print_errors_fp(FILE *fp);
    2. Specify method
        SSL_METHOD* method = SSLv23_server_method(void); // server method is the same as the client
    3. Set CTX
        SSL_CTX *ctx = SSL_CTX_new(SSL_METHOD*);
            // set the verify method
        void SSL_set_verify(SSL_CTX *, int, int *(int, X509_STORE_CTX *)); // SSL_VERIFY_<PEER, NONE>
            // load certificate
        void SSL_CTX_load_verify_locations(SSL_CTS *, const char *file, const char *path);
            // load local certificate
        int SSL_CTX_use_certificate_file(SSL_CTX *, const char *file, int type);
            // load private key
        int SSL_CTX_use_PrivateKey_file(SSL_CTX *, const char *file, int type);
            // validata private key and certificate
        BOOL SSL_CTX_check_private_key(SSL_CTX *);
        
    4. Attach to a connected socket
        SSL *SSL_new(SSL_CTX *);
        int SSL_set_fd(SSL *ssl, int fd); int SSL_set_rfd(SSL *, int); int SSL_set_wfd(SSL *, int); 
    5. SSL connect and communication
        int SSL_connect(SSL *ssl); int SSL_accept(SSL *ssl);
        int SSL_read(SSL *ssl, char *buf, int len);
        int SSL_write(SSL *ssl, char *buf, int len);
    6. Free
        int SSL_shutdown(SSL *ssl);
        void SSL_free(SSL *ssl);
        void SSL_CTX_free(SSL_CTX *);


**********************************************  MYSQL Programming  **********************************************
Direct Exexute:
    MYSQL *mysql_init(MYSQL *mysql);                        // init MYSQL struct
    MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *pwd, const char *db, 
        unsigned int port, const char *unix_socket, unsigned long client_flag); // connect to mysql server
    int mysql_query(MYSQL *mysql, const char *stmt_str);    // execute query
    MYSQL_RES *mysql_store_result(MYSQL *mysql);            // store query result
    unsigned int mysql_field_count(MYSQL *mysql);           // get last result column amount
    unsigned int mysq_num_field(MYSQl_RES *result);         // get result column amount
    my_ulonglong mysql_num_row(MYSQL_RES *result);          // get result row amount
    MYSQL_ROW mysql_fetch_row(MYSQL_RES *result);           // get next data from result
    void mysql_free_result(MYSQL_RES *result);              // free MYSQL_RES struct
    void mysql_close(MYSQL *connection);  

Prepared Statment:
    MYSQL_STMT *mysql_stmt_init(); 
    mysql_stmt_prepare(); // prepare stmt on server
    mysql_stmt_bind_param(); // set the values of any parameters
    mysql_stmt_execute();
    mysql_stmt_result_metadata(); obtain the result set meta data
    mysql_stmt_bind_result();   // retrieve result set row
    mysql_stmt_fetch();          // fetch data row by row
    mysql_stmt_next_result();   // more result: -1 = no, >0 = error, 0 = yes 
    

unsigned int mysql_errno(MYSQL *connection);  
char *mysql_error(MYSQL *connection);



**********************************************  Kernel Programming  *********************************************
Advantages:
    1. Don' have to rebuild kernel as ofen.
    2. Help diagnose system problems.
    3. Save memory.
    4. Much faster to maintain and debug.
Used for:
    1. Device drivers   2. Filesystem drivers   3. System calls   
    4.Network drivers   5. TTY line disciplines  6. Executeable interpreters
LKM utilities:
    insmod  rmmod   depmod  kerneld  ksyms  lsmod   modinfo   modprobe
What happen when An LKM loads:
    1. Search system for device it is know how to drive.
    2. Register itself as the driver for particular major number /proc/devices
    3. May register itself as the handler for the interrupt level that device uses / proc/interrupts
    4. May send setup commands to the device
    5. A nice device driver issuses kernel msg (/var/log/message) telling what devices if found and is prepared to
        drive. (dmesg can display recent kernel message)
    6. A network device driver works similarly, except that the LKM registers a device name of its choosing (eth0) 
        rather than major number. /proc/net/dev
    7. A filesystem driver, upon loading, register itself as the driver for a filesystem type of a certain name.
LKM procedure:
    moduel_init(...); module_exit(...);
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    