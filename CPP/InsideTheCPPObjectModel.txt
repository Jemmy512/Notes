********************************************** 1. Object Lessons **************************************************
Layout costs for Adding Encapsulation:
    1. Data members are directly contained within each class object;
    2. Function members: one copy only of each non-inline member function is gernerated;
        Each inline function has either zero or one definition of itself generated with module in which it is used.
    3. Virtual function is the primary layout and access-time overheads:
        1> The virual function mechanism in its support of an efficient run-time binding.
        2> A virtual base class in its support of a single, shared instance of a base class occurring multiple times
            with an inheritance hierarchy.
1.1 The C++ Object Model
    1. Nonstatic data members are allocated directly within each class  object.
    2. Static data members are stored outside the individual class object.
    3. Static and nonstatic function members are also hoisted outside the class object.
    4. Virtual funtions are supported in two steps:
        4.1 A table of pointers to virutal functions is generated for each class(virutal table, vtbl).
        4.2 A single pointer to associated virtual table is inserted within each class object(vptr).
            The setting, resetting, and not setting of the vptr is handled automatically through code generated with
                each class constructor, destructor, and copy assignment operator. 
            The type_info object associated with each class 
                in Support of runtime type identification(RTTI) is also addressed within the virtual table, usually
                within the table's first slot.
    Addint Inheritance:
        The original model of virtual base class support added a pointer into the calss object for each associated
            virtual base class. Alternative models have evolved that either introduce a virutal bases class table 
            or augment the existing virual tabls to maintain the location of each virual base calss.
1.3 An Object Distinction
    The C++ language supports polymorphism in the following ways:
        1. Through a set of implicit conversion, such as the conversion of a derived class pointer to a pointer of 
            it's public base type.
        2. Through the virtual function mechanism.
        3. Through the dynamic_case and typeif operator.
            if (circle *pc = dynamic_case<circle *>(pc)) ...
    The primary use of polymorphism is to effect type encapsulation through a shared interface usually defined within
        an abstract base class from which specific subtypes are derived.
    The memory requirement to represent a class object in general are the following:
        1. The accumulated size of its nonstatic data member
        2. Plus any padding(between members or on the aggreaget boundary itself) due to the alignment constrints.
        3. Plus any internally generated overhead to support the virtuals
      
      
********************************************** 2. The Semantics of Constructor ************************************
2.1 Default Constructor Construction
    If there is no user-declared constructor for class X, a default constructor is implicityly declared...
    A constructor is trivial if it is an implicitly declared default constructor...
    
    The Four conditions that default constructor is nontrivial:
        1. Member Class Object with Default Constructor.
            a. Compiler will generate default constructor for Class object which has ojbect member and without
                any constructor.
            b. Compiler will expand user defined contructor which not initialized the ojbect member
        2. Base class with constructor
        3. Class with virutal function
            I. The class ethier declares(or inherits) a virtual function
            II. The class is derived from an inheritance chain in which one or more base classes are virtual. 
            
            The following two class "augmentation" occur during compilation:
                I. A virtual function table is generated and populated with the address of the active virtual functions
                    for that class.
                II. Within each class object, an additional pointer member is synthesized to hold the address of the 
                    associated clas vtbl.
        4. Class with a virutal Base class
    Summary:
        The four above characteristics of a class under which the compiler needs to synthesize a default constructor 
            for a class that declare no constructor at all.
        The synthesized constructor fulfills only an implementation need. 
2.2 Copy Constructor Construction
Copy constructor happens:
    1. When we use =
    2. Pass an object as an argument to parameter of non-reference type
    3. Return an object from a function that has non-reference return type
    4. Brace initialize the elements of an array or elements of aggregate class
Default Member Initializaion
    A class object can be copied in two way:
        1. By initialization(copy constructor);
        2. By assignment(copy assignment).
    The Standard distinguishes between a trivial and nontrivial copy constructor. It is only nontrivial instance that 
        in practice is synthesized within the program. The criteria for determining whether a copy constructor is
        trivial is whether the class exhibits bitwise copy semantics.
Bitwise Copy Semantics -- NotÔºÅ
    When are bitwise copy semantics not exhibited by a class? There are four instances:
        1. When the class contains a member object of a class for which a copy constructor exists(either declared by class
            designer or synthesized by compiler).
        2. When the class is derived from a base class for which a copy constructor exists(either explicity declared
            synthesized by compiler).
        3. When the class declares one or more virtual functions.
        4. When the class is derived from an inheritance chain in which one or more base class are vitual.
    Summary:
        The four conditions above under which bitwise copy semantics do not hold for a class and the default copy 
        constructor, if undeclared, is considered nontrivial. Under these conditions, the compiler, in the absence of 
        a declared copy constructor, must synthesize a copy constructor in order to correctly implement the initialization
        of one class object with another.
 
2.3 Program Transformation Semantics
    Explicit Initialization:
        The required program transformation is two-fold:
            1. Each definition is rewritten with the initialization stripped out.
            2. An invocation of the class copy constructor is inserted.
    Argument Initialization:
        The implementation is to copy construct the actual argument directly onto its place within the function's 
            activation recored on the program stack. Prior to the return of the function, the local object's destructor
            , if defined, is applied to it. 
    Return Value Initialization:
        1. Add an additonal argument of type reference to the class object. This argument will hold the copy constructed
            "return type".
        2. Insert an invocation of copy constructor prior to the return statement to initialize the added arguement
            with value of the object being returned.
        3. A final transformation rewrites the function to have it not return a value.
    Optimization at Compiler Level:
        All return statements return the same named value, it is possible for the compiler itself to optimize the
            function by substituting the result arguement for the named return value. This optimization referred to 
            as the Named Return Value(NRV) optimization.
2.4 Member Initialization List:
    Member Initialization list is used in order for program to compile:
        1. When initialize a reference member
        2. When initialize a const member
        3. When invoking a base or member class constructor with a set of arguments
    The compiler iterates over the initialization list, inserting the initializations in the proper order within the 
        constructor prior to any explicit user code.
    The order in which the list entries are set down is determined by the declaration order of the members within the 
        class declaration.
            class Base {
            public:
                Base(int val) : j(val+1), i(j-1) {} // i is initialized before j 
            private:
                int i, j;
            };
  
********************************************** 3. The Semantics of Data *******************************************
