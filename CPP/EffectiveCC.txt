Item_1: View C++ as a federation of languages.
    A multiparadigm programming language, one supporting a combination of procedural, object-oriented, functional
        generic and metaprogramming features.
        
Item_2: Prefer consts, enums, and inline to #defines.
    When replacing #define with contants:
        1. Defining constant pointers.
        2. Class-specific constants. To limit the scope of a constant to a class, make it a member, and to ensuer there's at
            most one copy of the constant, make it a static member.
            
Item_3: Use const whenever possible.
    Const Member Function:
        The purpose is to identify which member functions may be invoked on const objects.
    Avoiding Duplication in const and Non-const Member Functions:
        Having the non-const version function call the const version is a safe way to avoid code duplication.
            class TextBlock {
            public:
                const char &operator[](std::size_t position) const {
                    ...
                    ...
                    return text[position];
                }
                
                char &operator[](std::size_t position) {
                    return 
                        const_cast<char &>(                     // cast away const on op[]'s return type;
                        static_cast<const TextBlock &>(*this)   // add const to *this's type;
                        [position]                              // call const version of op[];
                    );
                }
            };
        Compilers enforce bitwise constness, but you should program using logical constness.
        When const and non-const member functions have essentially identical implementations, code duplication can be
            avoided by having the non-const version call the const version.
            
Item_4: Make suer that objects are initialized before they're used.
    The rules of C++ stipulate that data members of an object are initialized before the body of a constructor is entered.
    A::A(string name, int age, string sex) {name = name; age = age; sex = sex;}
    A::A(string name, int age, string sex) : name(name), age(age), sex(sex) {}
        The assignment-based version first called default constructor to initialize name, age, sex then promptly
            assigned new value in those default-constructed ones. All the work performed in those default constructions 
            was wasted. The member initialization list approach avoids that problem.
    Manually initialize objects of built-in type, because C++ only sometimes initializes them itself.
    In a constructor, prefer use of the member initialization list to assignment inside the body of the constructor.
    Avoid initialization order problems across translation units by replacing non-local static object with local static obj.

Item_5: Know What Functions C++ silently Writes and Calls.
    Compilers may implicitly generate a class's default constructor, copy constructor, copy assignment operator, and destructor.
    If a class contains reference member, const member, and you want to support assignment operator, compiler refuse to work 
        unless you define your own assignment operator, in this case default assignment operator doesn't work.

Item_6: Explicitly disallow the use of compiler-generated functions you do not want.
    Before C++11:
        To disallow functionality automatically provided by compilers, declare the corresponding member functions private and 
            give no implementation.
    After C++11:
        use 'delete' keyword.
        
Item_7: Declare destructor virtaul in polymorphic base class.
    C++ sepecifies that a derived class object is deleted through a pointer to a base class with a non-virtual destructor, 
        results are undefiend. The derived part of the object is never destroyed but base class part typically would be 
        destroyed, thus leading a curious partially destroyed object.
    Polymorphic base class should declare virtual destructor. If a class has any virtual functions,it should have a virtual 
        destructor.
    Classes not designed to be base calsses or not designed to be used polymorphically should not declare virtual destructor.
    
Item_8: Prevent exceptions from leaving destructors
    Destructor should never emit exceptions. If functions called in a destructor may throw, the destructor should catch any
        exceptons, then swallow them or terminate the program.
    If class clients need to be able to react to exceptions thrown during an operation, the class should provide a regular
        function [i.e., non-destructor] that perform the operation.
        
Item_9: Never call Virutal Functions During Construction or Destruction
    Don't call virtual functions during construction or destruction, because such call will never go to a more derived class
        than that of the currently executing constructor or destructor.
        
Item_10: Having Assignment Operators Return a Reference to *this.
    The assignment operators return a reference to *this, this is a convention.
 
Item_11: Handle assignment to self in operator=
    In general, code that operates on references or poiters to multiple objects of the same type needs to consider that
        objects might be the same. Two objects need not even be declared to be of the same type.
    The traditional way to prevent self assignment is via an identity test at the top of the operator=.
    Make suer operator= is well-behaved when an object is assigned to itself. Techniques include comparing address of 
        source and target objects, careful statement ordering, and copy-and-swap.
    Make suer that any function operation on more than one object behaves correctly if two or more of the objects are
        the same.
     
Item_12: Copy all parts of an object.
    Copy functions should be sure to copy all of the object's data members and all of its base class parts(via calling
        appropriate base functions).
    Don't try to implement one of the copying functions in terms of the other. Instead, put common functionality in a
        third function that both call.
    
Item_13: Use objects to manage resources.
    To prevent resource leaks, use RAII(resource acquisition is initialization) objects that acquire resources in
        their constructors and release them in their destructor.
    Two commonly useful RAII calsses are std::shared_ptr and auto_ptr. shared_ptr is usually the better choise, 
        because it behavior when copied is inituitive. Copying an auto_ptr set it to null.
    Both auto_ptr and shared_ptr use 'delete' in their destructors, not 'delet[]'. There is nothing like auto_ptr 
        or shared_ptr for dynamically allocated arrays in C++, because vector and string can almost replace 
        dynamically allocated arrays.
        
Item_14: Think carefully about copying behavior in resource-manging classes.
    What happen when an RAII object is copied?
        1. Prohibit copying.
        2. Reference-count the underlying resource.
            class Lock{
                public:
                    explicit Lock(Mutex *pm) : mutexPtr(pm, unlock) {   // init shared_ptr with Mutex to point to and 
                        lock(mutexPtr.get());                           // the unlock function as the deleter
                    }
                    // There is no need to declare destructor, default it enough. Class's destructor automatically invokes
                    // the destructors of the class's non-static data members, here is mutexPtr, but its destructor will
                    // automatically call the shared_ptr's deleter--unlock.
                privae:
                    shared_ptr<Mutex> mutexPtr;
            };
        3. Copy the underlying resource.
        4. Transfer ownership of the underlying resource.
    Copying an RAII object entails copying the resource it manages, so the copying behavior of the resource determines
        the copying bahavior of the RAII object.
    Common RAII class copying behaviors are disallowing copying and performing reference counting, but other behavior
        are possible.
 
Item_15: Provide access to raw resources in resource managing classes.
    APIs often require access to raw resource, so each RAII calss should offer a way to get at the resource it manages.
    Access may be via explicit conversion or implicit conversion. In general, explicit conversion si safer, but 
        implicit is more convenient for clients.
 
Item_16: Use the same form in corresponding uses of the new and delete.
    Single object memory layout is generally different from arrays's. Array memory layout includes the size of the array.
    If you use [] in new expression, you should use [] in the corresponding delete expresion.
    
Item_17: Store newed object in smart pointers in standalone statements.
    C++ compilers are granted considerable latitude in determing the order in which these things are to be doen.
    
    Function ProtoType:
        int priority();
        void processWidger(shared_ptr<Widget> pw, int priority);
    Usage:
        processWidger(new Widget, priority()); // can't compile. no implicit conversion from raw pointer return by 
            //expression 'new Widget' to shared_ptr required by processWidger.
        processWidger(shared_ptr<Wiget> (new Widget), priority()) // can compile. But may cause resource leak. If 
            // 'new Widget' execute first, then priority(), but priority() yields an exception, in this case pointer 
            //    returned from 'new Widget' will be lost. 
    Store newed object in smart pointers in standalone statements. Failure to do this can lead to subtle resource
        leaks when exception are thrown.
       
Item_18: Make interfaces easy to use correctly and hard to use incorrectly.
    You should strive for these characteristics in all your interfaces.
    Ways to facilitate correct use include consistency in interfaces and behavioral compatibility with build-in type.
    Ways to prevent errors include creating new types, restricting operations on types, constraining object values,
        and eliminating client resource management responsibilities.
    shared_ptr supports custom deleters. This prevents the crosss-DLL problem, can be used to automatically unlock 
        mutexes.
    