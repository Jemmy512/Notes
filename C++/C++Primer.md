
# Chapter 0 Key Words
constexpr:
    Specifies that the value of a variable or function can apper in constant expression.
    conexpr variable Requirements:
        Its type must be a LiteralType.
        It must be immediately initialized.
        The full-expression of its initialization, including all implicit conversions, constructor calls etc, must
            be a constant exprssion.
    conexpr function requirements:
        It must not be virtual.
        Its return type must be LiteralType.
        each of its parameters must be LiteralType.

# Chapter 2: Variables and Basic Type
std::function: <functional>
    Syntax:
        template<Class R, Class....Args>
        class function<R(Args...)>;
    Class template std:: function is a general-purpose polymorphic function wrapper. Instances of std::function can
        store, copy and invoke any Callable target--functions, lambda expressions, bind expressions, or other function
        objects, as well as pointers to member functions and pointers to data members.
    Member functions:
        (constructor), (destructor), operator=, swap, assign(C++17), operator bool, operator()
    Target access:
        target_type: obtain the typeid of the stored target
        target: obtains a pointer to the stored target
    Non-member functions:
        std::swap, operator==, operator!=
    Usage:
        1. store a normal function
            function<void(int)> func = void (int a) { return ++a;};
        2. store a lambda
            function<sizt_t(Cumstomer&, Customer&)> func = [](Cumstomer &c, Customer &s) ->size_t{ return 0;};
        3. store the result of a call to std::bind
            function<void()> func = std::bind(print_num, 3317);
        4. store a call to a member function
            function<void(const Foo&, int)> func = &Foo::print_add; // get the address of the memeber functioin
        5. store a template function
            template<typename T> T g_Minux(T i, T j) { return i - j;}
            function<int(int, int)> func = g_Minux<int>;
        6. store a function object
            struct Minux {
                int operator()(int, int j) { return i - j; }
            }
            function<int(int, int)> func = Minux();

Value Category:
    1. glvalue: whose evaluation determine the identity of an object, bit-field, or function;
    2. prvalue: The pure value is the part of the traditional rvalue, is the middle value of the expression,
        can not take address.
    3. xvalue: demise value is generated by the rvalue. rvalue must be destroyed after the expression has ended.
        such as return x (x will be destroyed after copy), 1 + 2 (the middle value 3 will be destroyed).
    4. lvalue:  a string literal, such as "Hello, world!";
    5. rvalue:
The delctype Specifier:
    Syntax:
        decltype(entity)    decltype(expression)
    Inspects the declared type of the entity or the type and value category of an expression.
    1. If the argument is an unparenthesized id-expression a naming a structed binding, the decltype yields the
        reference type. (described in the specification of the structed binding declaration). (since C++17)
    2. If the argument is an unparenthsized id-expression or an unparenthesized class member access expression,
        then decltype yields the type of the entity named by this expression. If there is no such entity, or if
        the argument names a set of overloaded functions, the program is ill-formed.
    3. If the argument is any of other expression of type T, and
        1) if the value category of expression is xvalue, then decltype yields T&&;
        2) if the value category of expression is lvalue, then decltype yields T&;
        3) if the value category of expression is prvalue, then decltype yields T.
    If an expression is a function call which returns a prvalue of class type or is a comma expression whose right
        operand is such a function call, a temporary object is not introduced for materialized from that prvalue.
    If the name of an object is parenthesized, it is treated as an ordinary lvalue expression.
Const qualifier:
    1. We can't change the value the of const object after we create it, so it must be initialized.
    2. But we can the const variable via a pointer, the value of the addr pointer pointes is changed, but the const
        variable value is not changed.
        int a = 10; int *p = (int *)&a; *p = 20; // a is 10, *p is 20
    initialize with const:
        By default, const objects are local to file.
        The compiler will replaces the uses of the const variable with its value during compile time.
    Reference to const:
        To bound a reference to const we must use reference to const.
        const int i = 12;
        const int &j = i;
        int &k = i; // error: nonconst reference to a const object
    initialization and reference to const:
        There are two exceptions to the rule that the type of the reference must match the type of the object
            to which it refers:
                1. We can initialize the reference to const from the type that can be converted to the type of
                    reference.
                    float  a = 3.4;
                    const int &b = 3; // ok, b is 3
                    int &c = a; // error: invalid initialization of type of reference of type int & from int
                2. A reference to const may refer to an object that is nonconst.

    pointer and const:
        1. pointer to const: the rule is the same as reference.
        2. const pointer:
    top-lever const:

    constexpr and const expression:
        Wheather a given object is a constant expression depends on the types and initializers.
        Variables declared as constexpr are implicitly const and must be initialized by const expression.
        It's good idea to use constexpr for variable that intend to  use it as constant expression.
    pointer and constexpr:
        constexpr specifier applies to pointer, not the type to which the pointer points.

Dealing with Types:
    auto:
        Auto tell the compiler to deduce the type of the variable from the initializer which is required.
        Auto ordinarily ignores the top-level consts.
        When use reference, we are really using the object to which it refers.
        When we ask for a reference to auto-deduced type, top-level consts in the initializer are not ignored.
            const int ci = i, &cr = i;
            auto b = ci;    // int
            auto c = i;     // int
            auto d = &ci;   // const int * (& of const object is a low-lever const)
            auto e = &i;    // int *        (& of int object is int *)
            auto &h = ci;   // const int &, reference to auto-deduced, consts doesn't ignore
            auto &f = 42;   // error: cannot bind a plain reference to literal
            const auto &j = 42; // ok
    delctype:
        decltype((variale)); // always a reference
        decltype(variable);  // reference only when variable is a reference

# Chapter 3: string, vector and array

Array:
    1. Dimension of arrays must be a constant expression.
    2. A default-initialized array have undefined values. Random value given by compiler. eg: int arr[10];
    3. Character arrays can be initialized from a string literal. But string literal end with a null character,
        so array size must be bigger than the number of explicit elements.
        char arr[5] = "hello";   // error: dimension must be at least 6;
    4. No copy and assignment for arrays initialization.
    5. It’s much more easier to understand array declaration from right to left and from inside to out.
    6. begin() and end() function which are defined in iterator header return pointers to the first and the one past
        the last element in an array.
    7. The result of subtracting two pointers is a library type named ptrdiff_t (difference_type C++ container library)
        which is defined in cstddef header file and is a signed integer type.
    8.  The result of subtracting two null pointers is 0.
    9.  Unlike subscripts for vector and string (Library type such as vector and string that have subscript operator
        force the index used with subscript to be an unsigned value), the index for built-in subscript operator is not
        an unsigned value.
    10. To use a multidimensional array in a range for, the loop control variable for all but the innermost array
        must be references. (As with any array, when we use the name of a multidimensional array, it’s automatically
        converted to pointer to the first element of that array.)

# Chapter 6: Functions

    Overloaded Functions
Features of specified uses:
    Default Arguements:
        If a parameter has default arguement, all the parameter follow it must also have default arguement.
        A function can be declared mulitple times, but it can only have default specified once in a given scope.
        Defaults can only be specified if all paramters to the right already have defaults.
    Inline and constexpr function:
        A function defined entirely inside class/struct/union definition, whether it's a member or non-member
            friend funtion is implicitly an inline function.
        Inline function avoid function call overhead, it is expanded "in line" at each call.
        Inline specification is just a request to compiler.

        Constexpr function restriction:
            1. Return type and type of each parameter must be a literal type.
            2. Function body must contain exactly one return statement.
        Inorder to expand function immediately, constexpr functions are implicitly inline.
        Inline function bans to use loop(for, while), switch, exception interface declaration and recursive function.
    Aids for debugging:
        assert(expr);   // <cassert>
        NDEBUG

# Chapter 7: class

Some classes can’t rely on synthesized default constructor:
   1. Compiler generate default constructor only if we do not define any other constructors.
   2. Synthesized default initialization may do wrong things. Build-in or compound types can be initialized by
        undefined values.
   3. Compiler is unable to synthesize one default constructor. If a class has a member that has class type
        which doesn’t have a default constructor, so the compiler can’t initialize that member.
Benefits of Encapsulation:
   1. User code cannot inadvertently corrupt the state of an encapsulated object.
   2. The implementation of an encapsulated object can change over time without requiring changes in user-level code.

7.3 Additional Class features
7.3.1  class members revisited
    Defining a type member
        typedef  std::string::size_type pos; // typedef
        using  pos = std::string::size_type; // type alias
    Making Members inline
        It’s legal to specify inline on both the declaration and definition that both inside or outside
            the class body.
    Overloading Functions
        Overloading functions differ by numbers and/or types of parameters
    Mutable Data Member
        A mutable data member is never const, even it’s a member of a const object, we can modify a mutable
            data member inside a const function.
    Initializers for Data Member of Class Type
        In-class initializer followed by an = sign or curly brace
7.3.1 Functions That Return *this
    A const member function returns *this as a reference to const
        Screen &display (ostream &os)  {do_display(os); return *this; }
        const Screen &display (ostream &os) {do_display(os); return *this; }
        void do_display(ostream &os) {cout << contents << endl; }
    When non-const version of display call do_display, it’s this pointer is implicitly converted from a
        pointer to non-const to a pointer to const
    When we call display on an object, whether the object is const determines which version of display is called
7.3.4 Friendship Revisited
    Friendship Between Classes
        The members of friend class can access all members of class granting friendship


Making A Member Function a Friend
Overloaded Functions and Friendship
Friend Declarations and Scope
    Class and nonmember functions need not have been declared before they are used in a friend declaration.
    When a name is first appears in a friend declaration, it’s implicitly assumed to be part of surrounding scope.
        However, the friend is not actually declared in that scope.
    Even if we define the function inside the class, we must provide declaration out the class itself to make that
        function visible.
    struct X {
        friend void f() { return; } // friend function defined inside class
        x() {f();}                  // error: f is not declared
        void g();
        void h();
    }
    void X::g() { f(); }    // f hasn’t been declared
    void f();               // declare f function
    void X::h() { f(); }    // ok: declaration of f is now in scope
7.4 Class Scope
    Scope and Member Defined outside the Class
        Once the class name is seen, the remainder of class including the parameter list and function body
            is in scope of the class
        If a member function is defined outside the class, any name used in return type is out the scope of class.
            As a result, we must specify the class of which it is a member.
        // ScreenIndex which is a type name defined inside Window_mgr class
        Window_mgr::ScreenIndex  Window_mgr::addScreen(const Screen &s) {}
7.4.1 Name Lookup and Scope
    Class definition are processed in two phases:
        1. Members declaration are processed first
        2. Members body are processed after entire class has been seen
    Name Lookup for Class Member Declaration
        Name used in declaration, including names used for return type and types in parameter list, must see
            before they are used.
    Type Name Are Special
        An inner scope can redefine a name from outer scope, but if that name is a type, the class may not
            subsequently redefine that name.
    Normal Block-Scope Name Lookup inside Member Function
        It’s a bad idea to use same name for a parameter and a member
    After Class Scope, Look in the Surrounding Scope
        Names Are Resolved Where They Appear Within a File
7.5 Constructor Revisited
7.5.1 Constructor Initializer List
    Constructor Initializers Sometimes Are Required
        We must use constructor initializer list to provide values for members that are const or references
            or that are of a Class type that does not define a default constructor
    Order of Members Initialization
        A constructor that supplies default arguments for all its parameters also defines the default constructor
            FOO(string name = "XXX", string sex = "man", int age = 20) : name(name), sex(sex), age(age) {}
7.5.2 Delegating Constructor
    Sales_data(): Sales_data("", 0, 0);
    Sales_data(string s): Sales_data(s, 0, 0);
7.5.3 The Role of Default Constructor
    Default initialization happens:
        1. When we define non-static variables or arrays at block scope without initializer
        2. When a class has members of class type uses synthesized default constructors
        3. When a class member are not explicitly initialized in a constructor initializer list
    Value initialization happens:
        1. During array initialization we provide fewer initializer than the size of array
        2. When we define a local static object without initializer
        3. When we explicitly request value initialization by writing the expression
            of the form of T(), where T is the name of a type
7.5.4 Implicit Class-type Conversion
    One class-type conversion is allowed
        // item.combine(Sales_data sd);
        // error: "999-999" convert to string then convert to Sales_data
            item.combine("999-999");
        // ok
            item.combine( (string)"999-999" );
            item.combine( (Sales_data)"999-999" );
    Class-type conversions Are Not Always Useful
        Suppressing Implicit Conversions Defined By Constructor
        We can suppress implicit conversions defined by constructor by declaring the constructor as explicit
            explicit Sales_data( string &s) : book(s) { };
            explicit Sales_data( istream &is);
    "Explicit" can only be used in declarations of constructors and conversion operations which constructor
        can be called by only one simple argument.
    Explicit Constructor Can Be Used Only for Direct Initialization
7.5.5  Aggregate Classes
7.5.6 Literal Classes
7.6 static Class Members
    Can not declare a static member function as const and refer this in the function body
    Static members can be defined inside or outside the class body.  The static keyword is used only on the
        declaration inside the class body not on the definition outside the class body.
    Static members should be initialized outside the class body. We can provide in-class initializers for static
        members that have const integer type and must do so for static members that are constexpr of literal
        type. If there is an initializer inside the class there shouldn’t be another one outside the class.
    Even if a const static data member is initialized in the class body, the members ordinarily should be defined
        outside the class definition.


# Chapter 8: IO Library

8.1 The IO Class
8.1.1 No copy or assign for IO Object
8.1.2 Condition States
    IO type:  ios_base::iostate
    State flag:  ios_base::goodbit   ios_base::badbit  ios_base::eofbit  ios_base::failbit
    Functions:  s.good()  s.bad()  s.eof()  s.fail()  s.clear()  s.clear(flag)  s.rdstate()

    Once an error has accoured, subsequent IO operations on that stream will fail

    Interrogate the State of Stream
        Fail returns true if bad is set.
    Flushing the Output Buffer
        Flush:  flush the buffer but add no data
        Endl:  end the current line and flush the buffer
        Ends:   add null character and flush the buffer
        Buffers are not flushed if the program crashes
    Typing Input And Output Stream Together
        When an input stream is tied to an output stream, any attempt to read the input
        stream will first flush the buffer associated with output stream
8.2 File Input and Output
    The Open and Close Members
        Once a file is opened, the file stream remains associate the file.
        Open an opened file will fail and subsequent operations will also fail and set failbit
        Once the file is closed, we can open a new file.
    It’s good practice to verify the open succeeded.
    When a file stream object goes out the scope, the file it is bound is automatically closed.
    File Mode
        fstream::in out app(seek to the end before every write)
    ate(seek to the end immediately af open)  fstream::binary trunc(truncate the file)
    The only way to preserve existing date in a file opened by an ofstream is specify app or in mode explicitly.

# Chapter 12 Dynamic Memory

Common operation on shared_ptr and unique_prt
    shared_prt<T> p;        p->get();               p->man();   swap(m, n);                 unique_ptr<T> q;
Operation specified to shared_ptr
    make_shared<T>(args);   shared_ptr<T> p(q);     p = q;      p.unique(); p.use_count();
    shared_ptr<T> p(q)      shared_ptr<T> p(q, deleter)         shared_ptr<T> p(u)
    shared_ptr<T> p(p2, d)  p.reset()               p.reset(q)  p.reset(q, d)
Operation specified to unique_ptr
    unique_ptr<T, D> u(q);  u.release()             u.reset(q)
Operation specified to weak_ptr
    weak_ptr<T> w;          weak_ptr<T> w(sp);      w = p;      w.reset();
    w.use_count();          w.expired();            w.lock();
Programs tend to use dynamic memory for three purpose:
    1. They don’t know how many objects they need
    2. They don’t know the precise type of the objects they need
    3. They want to share data between several objects
If new is unable to allocate the request storage, it’ll throw an exception of type bad_alloc, we can
    use "nothrow" keyword to prevent it throw such exception, the result is a null pointer.
Smart pointer must be initialized directly, we can’t implicitly convert a built-in pointer to smart pointer
    eg: shared_ptr<int> p = new int(1024);  // error: implicit conversion
    shared_prt<int> p(new int (1024));      // ok: user direct initialization
Don’t mix ordinary pointer and smart pointer
    It’s dangerous to use built-in pointer to access the object owned by smart pointer, because
        we may not know when the object is destroyed.
Don’t use get to initialize or assign another smart pointer
Use get() to pass access to the pointer to the code that will not delete the pointer.
Smart pointer can automatically free the memory it manages when an exception occurs
Smart pointer pitfalls:
    1. Don’t use built-in pointer to initialize or set more than one smart pointer
    2. Don’t use get() to initialize or assign smart pointer.
    3. Pointer returned by get() will become invalid when last corresponding sp goes away.
    4. Don’t delete a pointer returned by get().
    5. If use sp manage resource other than memory allocated by new, pass a deleter.
    6. Passing and returning unique_ptr
There is one exception for the rule that we cannot copy or assign a unique_ptr: we do those when
    a unique_ptr is about to be destroyed.

Dynamic Arrays
    We can use empty parentheses to value initialize elements of a dynamic array but not the initializer inside
        the parentheses which means that we cannot use auto to allocate an array.
    It’s legal to create an array variable of size 0
        deleter [ ] pa; // delete a dynamic array.
    Shared_ptr does not directly support dynamic array, so:
        1. We must define our own deleter.
        2. Smart pointers do not support pointer arithmetic and subscript, to access the elements of a dynamic array
            we can use get() to obtain a built-in pointer.
        for (size_t i = 0; i < 10; i++)  {
            *(sp.get() + i) = i;    // get() obtains a normal pointer which support pointer arithmetic.
        }
The Allocator Class
    Decoupling the allocation from construction.
    Oporation:
        allocator<T> a;     a.allocate(n);  a.construct(p, args);   a.destroy(p);   a.deallocate(p, n);
    Algorithms to copy and fill the uninitialized memory <memory>
        // returns a pointer pointing to the element pass to the last constructed element
        uninitialized_copy(b, e, p2);           uninitialized_copy_n(b, n, p2);
        uninitialized_fill(b, e, t);            uninitialized_fill_n(b, n, t);

# Chapter 13: Copy, Assign and Destroy

The Copy constructor
    A constructor is a copy constructor if its first parameter is a reference to the class type, and any additional
        parameters have default values.
    If we do not define copy constructor the compiler will synthesize one for us even if we define any other
        constructor.

Difference between copy and direct initialization:
    Direct: we’re asking compiler use ordinary function matching to select the constructor
        that best matches the arguments we provide;
    Cope: we’re asking compiler to copy the right-hand operand to the object being created, converting if necessary.

Copy constructor happens:
    1. When we use =
    2. Pass an object as an argument to parameter of non-reference type
    3. Return an object from a function that has non-reference return type
    4. Brace initialize the elements of an array or elements of aggregate class

Why Copy construct first parameter must be a reference:
    To call copy constructor, we’d need to call copy constructor to copy the arguments, to copy the arguments,
        we’d need to call copy constructor and indefinitely.

Copy-assignment operator:
    Assignment operators ordinarily should return a reference to their left-hand operand.
    Compilers will generate synthesized copy-assignment operator if we don’t define it’s own.
    Some synthesized copy-assignment operator disallow assignment, otherwise, it assigns each right-hand object
        to the corresponding left-hand object of the class using copy-assignment operator for the type of that member.

Copy elision:
    1. In a return statement, when the oparand is a prvalue as the same class type as the return type
        T f() {
            return T(); // f(), only one call to default constructor of T
        }
    2. In a initialization of a variable, when the initializer expression is a prvalue of the same type
        as the variable type
            T x = T(T(f()));    // only one call to default constructor of T to initialize x

    3. In a return statement, when the operand is the name of a non-volatile object with automatic storage
        duration, which isn't a function parameter or a catch clause parameter, and which is of the same class
        type (ignoring cv-qualification) as the function return type. This variant of copy elision is known as
        NRVO, "named return value optimization".

    4. In the initialization of an object, when the source object is a nameless temporary and is of the
        same class type (ignoring cv-qualification) as the target object. When the nameless temporary is
        the operand of a return statement, this variant of copy elision is known as
        RVO, "return value optimization".

    5. In a throw-expression, when the operand is the name of a non-volatile object with automatic storage duration,
        which isn't a function parameter or a catch clause parameter, and whose scope does not extend past
        the innermost try-block (if there is a try-block).  ()

    6. In a catch clause, when the argument is of the same type (ignoring cv-qualification) as the exception
        object thrown, the copy of the exception object is omitted and the body of the catch clause accesses
        the exception object directly, as if caught by reference (there cannot be a move from the exception
        object because it is always an lvalue). This is disabled if such copy elision would change the
        observable behavior of the program for any reason other than skipping the copy constructor and the
        destructor of the catch clause argument (for example, if the catch clause argument is modified, and the
        exception object is rethrown with throw).   (sicen C++11)

If a class needs a destructor, it’s almost surely it needs copy constructor and copy-assign operator.

Classes that need copy need assignment, and vice versa.

Preventing Copy: =delete
    =delete must appear on the first declaration of the deleted function.
    We can specify =delete on any function.

The destructor should not be deleted
    The compiler won’t let us define variables or temporaries of type that has deleted destructor.

The Copy-control members may be synthesized as deleted
    1. Deleted destructor:  the class has member whose own destructor is deleted or inaccessible.
    2. Deleted copy constructor: class has member whose own copy constructor is deleted or inaccessible or has
        member with deleted or inaccessible destructor.
    3. Deleted copy-assignment operator: if a member has deleted or inaccessible copy-assignment operator, or the
        class has const or reference member.
    4. Deleted default constructor: if the class has deleted or inaccessible constructor; or a reference member
        does not have an in-class initializer; or a const member whose type does not explicitly define a default
        constructor and that member does not have in-class initializer.

Two points in mind when writing assignment operator:
    1. Assignment operator should work correctly if an object is assigned to itself
    2. Most assignment operators share work with destructor and copy constructor

Good pattern to write assignment operator:
    1. Copy the right-hand operand into the local temporary
    2. Destroy the existing members of the left-hand operand
    3. Copy the data from temporary into the members of the left-hand operand
        HasPtr & operator= (HasPtr &rhs) {
            string p = new string(*rh.ps);  //  first step
            delete ps;                      //  second step
            this->ps = p;                   //  third step
            this->num = rhs.num;
            return *this;
        }

        HasPtr& operator=(HasPtr& rhs) {
            if (this != &rhs) {
                delete this->ps;
                this->ps = string(*rhs.ps);
                this->num = rhs.num;
            }

            return *this;
        }

lvalue/rvalue reference:
    1. Rvalue reference may  be bound only to an object that is about to be destroyed.
    2. Lvalue reference refers to an object's identity whereas rvalue refers to an object' value.
    3. Functions that return lvalue references, along with assignment, subscript, dereference and prefix
        increment/decrement operators, are all examples of expression that return lvalue.
    4. Functions that return rvalue reference, along with arithmetic, relational, bitwise, postfix
        increments/decrement  operators, are all yield rvalue.

        We can bind either lvalue to const or rvalue to these expressions, and its lifetime is extended.
            int &&x = 2 + 3; // x itself a lvalue, bug it binds to a rvalue
        Const reference can accept both lvaue reference and rvalue reference.
        Rvalue bind to a const reference, it's lifetime is extended.

    5. Because rvalue reference can only be bound to temporaries, so:
        1. There can be no other users of that object
        2. These facts together mean that code uses rvalue reference is free to take over the resource from the
            object which the reference refers.
        3. The referred-to object is about to be destroyed
    6. Rvalue references refer to objects that are about to be destroyed. Hence, we can "steal" the state from an
        object bound to rvalue reference.
    7.  A variable is an lvalue; we cannot bind an rvalue reference to an variable even if that variable is defined
        as an rvalue reference type.

std::move <utility>
    1. We can destroy the moved-from object and assign a new value to it, but cannot use the value of moved-from
        object.
    2. Move constructor and move assignment operator that cannot throw exceptions should be marked as noexcept.
    3. Unless the library knows that our move constructor can't throw, it will do extra work to cater to the
        possibility that moving an object of our class type might throw.
    4. Move operation doesn't throw because two interrelated facts: first, although, move operations usually
        don't throw exceptions, they are permitted to so. Second,  the library provide guarantees to what they do
        if an exception happens.
    5. After move operation, the moved-from object must remain a valid, destructible object but user may make no
        assumptions about its value.
    6. The compiler synthesizes the move constructor and move assignment operator only if the class doesn't define
        any of its copy-control members and only if all data members can be moved constructed and moved assigned,
        respectively.
    7. Move operations are never implicit defined as deleted:  e. if ask compiler to generate a move operation by
        using =default, then the operation will be defined as deleted.
    8. Move members are defined as deleted:
        a. if the class has a member that defines its own copy members but move members or if the class has a
            member that doesn't define its own copy members for which compiler is unable to synthesize move members.
        b. if the class has a member whose move members are deleted or inaccessible.
        c. if the destructor of the class is defined as deleted or inaccessible
        d. if the class has members that are const or reference member.
    9. Class has define its own move constructor or move-assignment operator must define its own copy operations.
        Otherwise, those members are deleted as default.
    10. Lvalues are moved, lvalues are copied but r values are copied when there is no move constructor.


Move Iterator:
    Return rvalue reference by calling library "make_move_iterator" function which takes a normal iterator and returns
    a rvalue reference rather than normal iterator which return lvalue reference.

Rvalue LValue reference member function:
    In order to maintain backward compatibility, the library continue allow assignment to rvalue. However,
        we can prevent this feature by indicating rvlaue/lvalue reference in the same way that we define const
        member functions, we place a reference qualifier (& or &&) after the parameter list.
    A function can be both const and reference qualified, the reference must follow const.

Overloading and Reference Function
    If a member function has a reference qualifier, all the versions of that function with same parameter
        list must have reference qualifier(overloading functions have ref-qualifier).
    void func() const &;
    void func() const &&;

# 14 Overloaded Eperator and Conversion

When an overloaded operator is a member function, this is bound to the left-hand operand. Member operator functions have one less (explicit) parameter than the number of operands.

An operator function must either be a member of a class or have at least one parameter of class type.

Ordinarily, the comma, address-of, logical AND, and logical OR operators should not be overloaded.

## Overloading the output operator<<
Ordinarily, the first parameter of output is a non const ostream reference, non const because writing to the stream can change it state, reference because we can't copy ostream object. The second parameter should be a const reference to class type.
```C++
ostream& operator<<(ostream& os, const T& t);
```

To be consistent with other output operator, operator<< returns a ostream reference.

Output operator should print the contents of the object with mininal formatting, they shouldn't print a newline.

Io operators mube be nonmember functions and usually be declared as friends.

## Overloading the input operator>>
Input operators must deal with possibility that input might faill. Output operators generally don't bother.

Input operator should decide what, if anything, to do about error recovery.

## Arithmetic and Relational operator
Ordinary, the parameter of arithmetic and relational operator should be const. An arithmetic generates a new value which is the result of computation on its two params

Classes that define both arithmetic operator and related compound assignment operator ought to implement the arithmetic operation by using the compound assignment.

## Relational Operator
If a single logical definition for < exists, classes usually should define the < operator. However, if the class also has ==, define < only if  the definitions of < and == yield consistent results.

## Assignment operator
Assignment operators must, and ordinarily compound-assignment operators should, be defined as members.

These operators should return a reference to the left-hand operand.

## Subscript Operator
If a class has a subscript operator, it usually should define two versions:
1. one that returns a plain reference
2. the other that is a const member and returns a reference to const.

## Increment and Decrement Operator
To be consistent with the built-in operators, the postfix operators should return the old (unincremented or undecremented) value. The rvalue is returned as a value, not a reference. But the prefix operators return reference.
```C++
p.operator++(0);  // call postfix operator
++p.operator++(); // call prefix operator++
```

## Function-call operator
The function-call operator must be a member function.

A class may define multiple versions of the call operator, each of which must differ as to the number or types of their parameters.

Function objects are often used in combination with the standard algorithme.

## Lambdas Are Function Objects
When we write a lambda, the compiler translates that expression into an unnamed object of an unnamed class which contain an overloaded function-call operator which is const function but we can use 'mutable' key word to modify the captured data members.

Classes generated from lambda expression have a deleted default constructor deleted assignment operator, and a default destructor, where has copy/move constructor depends on the type of the captured data members.

## Callable Objects:
1. functions
2. pointer to function
3. lambda
4. objects created by bind
5. classes that overloaded function-call operator

## Call signature
specifies the type returned by a call to the object and the argument type that must be passed in the call.

The Library function Type (P 577) <functional>
* Defined in functional header, represent callable objects with return type and parameter type.
* We cannot directly store the name of an overloaded function in an object of type function.
* function<int(int, int)> f2 = [](int i, int j) { return i % j; };

function:
* function<T> f;  function<T> f(nullptr);  function<T> f(obj);  f(args); result_type;
* deprecated C++17: argument_type;  first_argument_type;  second_argument_type;

## Conversion Operator
A conversion function must be a member function, may not specify return type, and must have an empty parameter list, and is called automatically. The function usually should be const.

Conversion operators are applied implicitly that can yield surprising results, we can prevent this by using `explicit` keyword.
```C++
explicit operator int() const { return val;}    // define explicit conversion
static_cast<int>(obj);                          // use explicit conversion
```

Explicit conversion can implicitly use as:
* The condition of an if, while, do statement
* The condition expression in a for, logical NOT(!),  OR(||), AND(&&), (?:).

## new and delete:
Category:
* new/delete/new[]/delete[] operator      // global, can not be overloaded
* operator new/delete/new[]/delete[]
* placement new/new[]                     // note: there are no placement delete/delete[]

Process of new and delete:
* new: call `operator new` to malloc memory, call constructor construct object and return pointer
* delete: call destructor destruct object, free memory

# 15 Object-Oriented Programming

# Chapter 16 Template
Template arguments used for non type template parameters must be constant expression.

Template programs should try to minimize the number of arguments placed on the arg types.

Function templates and member functions of class templates are ordinarily put into head file.

It's up to the caller to guarantee that the arguments passed to the template support any operations that template uses, and that those operations behave correctly in the context in which the template uses them.
## Defining a Template
### Function Templates
```C++
template <typename T>
int compare(const T &v1, const T &v2)
{
    if (v2 < v1) return 1;
    if (v1 < v2) return -1;
    return 0;
}
```
1. Instantiating a Function Template
2. Template Type Parameters
3. Nontype Template Parameters
4. inline and constexpr Function Templates
5. Writing Type-Independent Code


### Class Template
A function of a class template is instantiated only if the program uses that function.

There is one exception to the rule that when we use a class template we must supply the template arguments that is in the scope of template itself.

Class and it's friends can both be template or not. A class that has non-template friends grants that friends access or instantiation of the template. When friends is itself a template, the class granting friendship controls friendship includes all instantiations or specified instantiation.

In the scope of the class template, we may refer to the template without specify the template arguments.

In order to refer to a specific instantiation of a template, we must declare first the template itself.
```C++
template<typename> class Friend;
template<typename> class Base;
template<typename T> bool compare(const Base<T>&, const Base<T>&);

template<typename T>
class Base {
public:
    friend bool compare<T>(const Base<T>&, const Base<T>&);

    /* one-to-one friendShip
     * Forward declaration necessary */
    friend class Friend<T>;

    /* Specific friendShip
     * Forward declaration necessary */
    friend class Friend<int>;

    /* Generic friendShip
     * Forward declaration unnecessary
     * All instantiations are friends to each instantiation of Base */
    template<typename T> friend class Friend;
};
```
1. References to a Template Type in the Scope of the Template
2. Member Functions of Class Templates
3. The check and Element Access Members
4. Blob Constructors
5. Instantiation of Class-Template Member Functions
6. Simplifying Use of a Template Class Name inside Class Code
7. Using a Class Template Name outside the Class Template Body
8. Class Templates and Friends
9. One-to-One Friendship
10. General and Specific Template Friendship
11. Befriending the template's own type parameter:
    ```C++
    template<typename Type> class Bar {
        // if Type is class type Base, so Base is friend of Bar
        friend Type;                 // grants access to Type used to instantiate the Bar
    }
    ```
    Whatever Type is a class or build-in type it works good.
12. Template Alias

    Because template is not a type, we cannot define a typedef that refers to a template. But using:
    ```C++
    // Syntax:
    using identifier attr(optional) = type-id ;
    template < template-parameter-list >
    using identifier attr(optional) = type-id ;
    ```
13. static Members of Class Templates
    ```C++
    template<typename T>
    class Foo {
    public:
        static T count(T a) {
            return 10;
        }

        static string count() {
            return "yes";
        }
    };

    Foo<string> fo1;
    Foo<int> fo2;
    cout << fo1.count() << endl;
    cout << fo2.count(5) << endl;
    cout << Foo<int>::count() << endl;
    ```

### Attribute specifier sequence(since C++11)
[[attr]] [[attr1, attr2, attr3(args)]] [[namespace::attr(args)]] alignas_specifier
Formally, the syntax is:
    [[ attribute-list ]]                (since C++11)
    [[ using attribute-namespace : attribute-list ]]                (since C++17)

where attribute-list is a comma-separated sequence of zero or more attributes (possibly ending with an ellipsis ... indicating a pack expansion)
identifier
identifier ( argument-list )
attribute-namespace::identifier
attribute-namespace::identifier ( argument-list )

1. simple attribute, such as [[noreturn]]
2. attribute with arguments, such as [[deprecated("because")]]
3. attribute with a namespace, such as [[gnu::unused]]
4. attribute with both a namespace and an argument list

If using: namespace appears in the beginning of an attribute list, no other attributes in the attribute list can specify a namespace: the namespace specified in a using applies to them all:
* [[using CC: opt(1), debug]] // same as [[CC::opt(1), CC::debug]]
* [[using CC: CC::opt(1)]]    // error: cannot combine using and scoped attribute

Storage Class Specifier
* Auto:  It was allowed in object declared in block scope or in function parameter list. Auto duration.
* Register: It is allowed in object declared in block scope or in function parameter list. Auto duration.
* Extern:  Used for variable and object.
* Static:   It is allowed in declaration of objects, functions and anonymous unions.
* Thread_local: It is allowed in object declared at namespace scope, function declared at block scope and and
        static data member.

1. Storage duration: automatic, static, thread, dynamic.
2. Linkage: no-linkage, internal-linkage, external-linkage.

### Template Parameter
Template Parameters follow normal scoping rules.

A name used as template parameter can not be reused within template.

By default, `the language assumes a name accessed through scope operator is not a type`, so we use keyword **`typename`** to tell compiler that we are using a name that is a type name of template.

When we want to inform the compiler that a name represents a type, we must use the keyword typename, not class:
```C++
template <typename T>
typename T::value_type top(const T& c);     // T is a class type
```

1. Template Parameters and Scope
2. Template Declarations
3. Using Class Members That Are Types
4. Default template Arguments:
    ```C++
    template<typename T = int> void f(T a, T b);    f<string>("3", "5");    f<>(2, 3);  // use default argument
    template<class T = int> class Base;             Base<string> ba;        Base<> b;
    ```
5. Template Default Arguments and Class Templates

### Member template
Category: member template for normal class and class template.

When we define a member template outside of the class template we must provide class template parameter list followed function template parameter list.

As usual, compiler typically deduce template arguments for the member template’s own parameter from arguments passed in the call.
```C++
template<typename T>
template<typename IT> void Base<T>::func(IT &a, IT &b) { return;  }
Base<double> base;                base.func(4, 5);
```

1. Member Templates of Ordianary (Nontemplate) Classes
2. Member Templates of Class Templates
3. Instantiation and Member Templates

### Controlling Instantiations
References and pointers don't need instantiation.

Compiler will instantiate a template for every file which contain this template with same arguments, In large system the overhead of this can be significant, we can avoid this through explicit instantiation.
```C++
// instantiation declaration and definition
extern template class Blob<string>;             // instantiation declaration
template int compare(const int&, const int&);   // instantiation definition
```

An instantiation definition for a class template instantiates all the members of that template including inline member functions.

When compiler sees an extern instantiation declaration it will not generate code for that instantiation until it sees that (non extern ) definition, so we  must provide only one definition for that template instantiation declaration which may appear in multiple files of the program.

### Efficiency And Flexibility
1. Binding the Deleter at Run Time
2. Binding the Deleter at Compile Time


## Template Argument Deduction
### Conversion and Template Type Parameter
A very limited number of conversions are supplied :
* const conversion: A parameter that is a reference or pointer to const can be passed a reference or
    pointer to non-const object.
* Array- or function-to-pointer conversion.
* Const conversion and array or function to pointer are the only automatic conversions for arguments to parameters with template types.

1. Function Parameters That Use Same Template Parameter Type
    * Because there are limited conversions, the arguments to parameters must have the essentially same type.
    * If the deduced types do not match, then the call is an error.
2. Normal Conversion for Ordinary arguments

### Function-Template Explicit Arguments
1. Specifying an Explicit Template Argument
    * Explicit template argument(s) are matched to corresponding template parameter(s) from left to right.
    ```C++
    // poor design: users must explicitly specify all three template parameters
    template<typename T1, typename T2, typename T3> T3 alternative_sum(T2, T1);

    // error: can’t infer initial template parameters
    auto val3 = alternative_sum<long long>(i, lng);

    // ok: all three parameters are explicitly specified
    auto val2 = alternative_sum<long long, int, long>(i, lng);
    ```
2. Normal Conversions Apply for Explicitly Specified Template Arguments
    * If we explicitly specify template parameter type, normal conversion apply.
    ```C++
    template<typename T> bool compare<T, T>
    compare(2.3, 4);        // error;
    compare<int>(2.3, 4);   // OK
    ```

### Trailing Return Types and Type Transformation
```C++
template<typename It>
auto fcn(It beg, It end) -> decltype(*beg) {
    /* The dereference operator returns an lvalue, so
     * return a reference to an element from the range */
    return *beg;
}
```

1. The Type Transformation Library Template Classes
    ```C++
    /* Header: <type_traits>
     * must use typename to use a type member of a template parameter; see § 16.1.3 (p. 670) */
    template <typename It>
    auto fcn2(It beg, It end) -> typename std::remove_reference<decltype(*beg)>::type {
        // return a copy of an element from the range
        return *beg;
    }
    ```

### Function Pointers and Arguments Deduction
```C++
template<typename T>
int compare(const T&, const T&);

int(*pf)(const int&, const int&) = compare;

// The type of parameters int pf determines the type of template arguments for T.
void func(int (*) (const string&, const string&);
void func(int (*) (const int&, const int&);
func(compare); // error: which version of func is called?
func(compare<int>); // ok
```
When the address of a function-template instantiation is taken, the content must be such that it allows a unique type or value to be determined for each of template parameter.

### Template Arguments Deduction and Reference
1. Type Deduction from Lvalue Reference Function Parameter
    * When the parameter of function is a non-const ordinary reference we can only pass lvalue;
    * When it’s a const reference we can pass any kind of arguments, object, temporary or literal value.
2. Type Deduction from Rvalue Reference Function Parameter
    * When the parameter of function is a rvalue reference we can only pass rvalue.
3. Reference Collapsing and Rvalue Reference Parameter
4. Reference Collapsing and Rvalue Reference Parameter
    * References collapse to form rvalue reference only in the specific case of an rvalue reference to
        rvalue reference.
    * Reference collapsing applies only when a reference to a reference is created indirectly, such as in
        a type alias or a template parameter.
    * An argument of any type can be passed to a function parameter that is a rvalue reference to a
        template parameter type.
5. Writing Template Functions with Rvalue Reference Parameters

Reference collapse apper in following context:

instantiation of template; generation of auto; typedef with class type; decltype

For Mod<T>, where Mod is | If T is | Then Mod<T>::type is
--- | --- | ---
remove_reference | [X& or X&&] [otherwise] | [X] [T]
add_const | [X&, const X, or function] [otherwise] | [T] [const T]
add_lvalue_reference | [X&] [X&&] [otherwise] | [T] [X&] [T&]
add_rvalue_reference | [X& or X&&] [otherwise] | [T] [T&&]
remove_pointer | [X*] [otherwise] | [X] [T]
add_pointer | [X& or X&&] [otherwise] | [X*] [T*]
make_signed | [unsigned X] [otherwise] | [X] [T]
make_unsigned | [signed type] [otherwise] | [unsigned T] [T]
remove_extent | X[n] otherwise | X T
remove_all_extents | X[n1][n2]... otherwise | X T

Writing Template Functions with Rvalue Reference Parameter
* Rvalue reference are used in one of the two contexts: either the template is forwarding it parameters
        or the template is overloaded.

### UnderStanding std::move
```C++
template <typename T>
typename remove_reference<T>::type&& move(T&& t) {// reference collapsing may happen
    // static_cast covered in § 4.11.3 (p. 163)
    return static_cast<typename remove_reference<T>::type&&>(t);
}
```

### Forwarding: <utility>
```C++
template<typename T> T&& forward(typename remove_reference<T>::type& param) {
    return static_cast<T&&>(param);
}
```
1. Define Function Parameter Retain Type Information
    * A function parameter that is an rvalue reference to a template type parameter can preserve constness and lvalue / rvalue property of corresponding arguments.
2. Using std::forward<T> to Preserve Type Information in a Call
    * Must be used with an explicit template argument,  return type is T&&.
    * When used with function parameter that is an rvalue reference to template type parameter(T&&), forward represent all details about an argument’s type.
3. As with std::move, it’s a good idea not to provide a using declaration for std::forward.

## Overloading and Templates
Function matching is affected by the presence of function template:
* The candidate functions for a call include any function-template instantiation for which template argument deduction (§ 16.2, p. 678) succeeds.
* The candidate function-templates are always viable, because template argument deduction will have eliminated any templates that are not viable.
* As usual, the viable function (template and nontemplate) are ranked by the conversions, if any, needed to make a call. Of course, the conversion used to make a call are quite limited.
* If there are several functions that provide an equally good match:
    - If there is one only `nontemplate function`, the nontemplate function is the best match.
    - If there is no template function, the `more specialized template function` is best match.
    - otherwise, the call is ambiguous.


1. Writing Overloaded Templates
2. Multiple Viable Templates
    * When there are several overloaded templates that provide an equally good match, the more specialized version is prefered.
3. Nontemplate and Template Overloads
4. Overloaded Templates and Conversions
5. Mission Declaration Can cause Program Misbehave
    * Declare every function in an overloaded set before you define any of the function. That way you don’t worry whether the compiler will instantiate a call before it sees the function you intended to use.

## Variadic Templates
The sizeof... Operator
```C++
// sizeof... operator can get parameter pack size
template<typename T, typename... Args>;
void foo(const T&, const Args&... rest);
```

### Writing A Variadic function Template
Variadic function are always recursion.
```C++
/* function to end the recursion and print the last elements
 * must be declared before the variadic version of print is defined */
template<typename T>
ostream& printf(ostream &os, const T &t) {
    return os << t ;
}

template<typename T, typename... Args>
ostream& printf(ostream& os, const T& t, const Args&... rest) {
    os << t << ",";
    return printf(os, rest...); // recursion call
}
```

### Pack Expansion
1. Understanding Pack Expansions

### Forwarding Parameter Packs

## Template Specialization
A specialization is a separate definition of template in which one or more template parameter are specified to have particular types.
1. Defining a Function Template Specialization
    ```C++
    template<typename T>
    int compare(const T&, const T&);

    template<>    // indicate this is a fully specialization
    int compare(const char* const &, const char*&);
    ```
2. Function overloading Versus Template Specialization
    * Specializations instantiate a template, they do not overload it. As result, they have no effect on function matching.
    * In order to specialize a template, a declaration for the original template must be in the scope.
    * Moreover, a declaration for a specialization must be in scope before any code use that instantiation.
    * Templates and their specializations should be declared in the same header. Declaration for all template with name should appear first, followed by any specializations of those templates.
    * If declaration for a specialization missing, code works good, because compiler will generate code from original template.

3. Class Template Specialization

    Specialize hash template:
    ```C++
    namespace std {
        template<> // indicates we are fully specializing a template
        struct hash<sales_data> {
            typedef size_t return_type;
            typedef sales_data arguments_type;
            size_t operator(const sales_data &) const;
        };

        size_t hash<sales_data>::()(const sales_data &s) const {
            return hash<string>()(s.bookNo)^
            hash<unsigned>()(s.units_sold)^
            hash<double>()(s.revenue);
        }
    }
    ```
    We can add members to namespace after open it.

5. Class-Template Partial Specialization
    ```C++
    // A class partial specialization is itself a template.
    // original, most general template
    template<class T>
    struct remove_reference {typedef T type;};

    // partial specializations that will be used for lvalue and rvalue references
    template <class T>
    struct remove_reference<T&> // lvalue references
    { typedef T type; };

    template <class T>
    struct remove_reference<T&&> // rvalue references
    { typedef T type; };
    ```

6. Specializing Members But Not Class
    ```C++
    template<typename T>
    struct Foo {
        Foo(const T &t = T()) : men(t){}
        void Bar();
        T men;
    };

    template<typename T>
    void Foo<T>::Bar() {
       std::cout << "general" << std::endl;
    }

    template<> // we're specializing
    void Foo<int>::Bar() {
       std::cout << "partial" << std::endl;
    }

    Foo<string> fs;// Foo<string>::Foo()
    fs.Bar();      // "general", Foo<string>::Bar()

    Foo<int> fi;    // Foo<int>::Foo()
    fi.Bar();       // "partial", uses specialization of Foo<int>::Bar()
    ```

# Chapter 17
A tuple can be thought of as a "quick and dirty" data struct.

Tuple type:
```C++
tuple<T1, T2, T3...> t;  tuple<T1, T2, T3...>  t(V1, V2, V3..);  make_tuple(V1, V2, V3...);  get<i>(t);
tuple_size<tupleType>::value;    tuple_element<i, tupleType>::type;    swap(...);
```

Bitset:
```C++
bitset<n> b; bitset<n> b(u);  biset<n> b(s, pos, m, zero, one);  bitset<n> b(cp, pos, m, zero, one);
any()  all()  none()  count()  test(pos)  set(pos, v)  set()  reset(pos)  flip(pos)  flip()
```

Regular Expression:<regex>
```C++
Regex  regex_match  regex_search  regex_replace  regex_iterator  smatch ssub_match
(seq, m, r, mfg)  (seq, r, mft)
```

# Chapter 18
## 18.2 Namespace
### 18.2.1 Namespace Definition

Each namespace is scope

Namespace can be discontiguous

Namespaces that defien multiple, unrelated types, should use separate files to represent each types that the namespace defines.

Namespace members are possible to defined outside the namespace, but not in the unrelated namespace.

inline namespace: can be used as if they were direct members of the enclosing namespace.

unnamed namespace, variables defiend in an unnamed space have static lifetime: they are created before their first use and destroyed when the program ends.

The use of file static declarations is deprecated by the C++ standard. File static should be avoided and unnamespaces used instead.

### 18.2.2 Using namespace members
Namespace aliases
```C++
namespace cplusplus_primer{};
namespace primer  = cplusplus_primer;
```

1. using Declaration
    * introduce _namespace members_ into other namespaces and block scopes
    * introduce _base class members_ into derived class definitions
    * introduce _enumerators_ into namespaces, block, and class scopes (since C++20)
2. using Directives
    * Allows us to use the unqualied form of a namespace name. Unlike a using declaration, we retain no control over which names are made visile---- they all are.
    ```C++
    using namespace std::string;
    ```
3. Using directives and scope

### 18.2.3 Classes, Namespaces, and Scope
Arguemnt-Dependent Lookup and Parameter of Class Type

# FAQ
1. vptr and vtbl(virutal function table and it's pointer):
    [refer]https://www.nowcoder.com/profile/3669004/test/13503903/22584#summary
    http://blog.csdn.net/haoel/article/details/1948051
    * When new an object, the compiler only allocates space for member variables while member functions
        are shared among objects belonging to same class.
    * The compiler adds _vptr to class automatically, and ensures contents of _vtbl at compile time, initializes
        _vptr in constructor of the class. _vptr at the begining of the class in memory. The objects of the class
        share the _vtbl of the class.
    * _vtbl is essentially an array of pointers that hold function pointers
    * In multi-inheritance, each base classes _vtbl stored in the derived class in defined order, and derived
        class shares the same _vptr as the first base class.
    * virtual functions declared in the derived class not only overwrite the virtual functions corresponding
        to each base class but also add to virtual function table of the first base class.
    * _vptr and _vtbl memory Layout:
        _vptr stored in the begining of the class momory in heap.
        _vtbl stored in .rodata segment.
        virtual functions themselves stored in .text segment.
    * Polymorphism process:
        base pointer(stack) ==> _vptr(heap) ==> _vtbl(.rodata) ==> .text
2. Scope(::) operator purpose:
    * To access the global variable when there is a local variale with the same name.
    * To define functions outside the class.
    * To access class's staic variable.
    * In case of the multiple Inheritance.
3. Single, multiple and virtual inheritance:
