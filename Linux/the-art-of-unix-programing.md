# Preface
Knowledge lets you deduce the right thing to do; expertise makes the right thing a reflex, hardly requiring conscious thought at all.

# 1 Philosophy: Philosophy Matters
## 1.6 Basics of the Unix Philosophy
1. `Modularity`: Write simple parts connected by clean interfaces.
2. `Clarity`: Clarity is better than cleverness.
3. `Composition`: Design programs to be connected to other programs.
4. `Separation`: Separate policy from mechanism; separate interfaces from engines.
5. `Simplicity`: Design for simplicity; add complexity only where you must.
6. `Parsimony`: Write a big program only when it is clear by demonstration that nothing else will do.
7. `Transparency`: Design for visibility to make inspection and debug- ging easier.
8. `Robustness`: Robustness is the child of transparency and simplicity.
9. `Representation`: Fold knowledge into data so program logic can be stupid and robust.
10. `Least Surprise`: In interface design, always do the least surprising thing.
11. `Silence`: When a program has nothing surprising to say, it should say nothing.
12. `Repair`: When you must fail, fail noisily and as soon as possible.
13. `Economy`: Programmer time is expensive; conserve it in preference to machine time.
14. `Generation`: Avoid hand-hacking; write programs to write programs when you can.
15. `Optimization`: Prototype before polishing. Get it working before you optimize it.
16. `Diversity`: Distrust all claims for “one true way”.
17. `Extensibility`: Design for the future, because it will be here sooner than you think.
