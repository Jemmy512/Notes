
# Item_1: Distinguish between pointers and references.

# Item_2: Prefer C++-style casts.

# Item_3: Never treat arrays polymorphically.

# Item_4: Avoid gratuitous default constructors.

# Item_5: Be wary of user-defined conversion functions.

# Item_6: Distinguish between prefix and postfix forms of increment and decrement operators.

# Item_7: Never overload &&, ||, or ,.

# Item_8: Understand the different meanings of new and delete.

# Item_9: Use destructors to prevent resource leaks.

# Item_10: Prevent resource leaks in constructors.

# Item_11: Prevent exceptions from leaving destructors.

# Item_12: Understand how throwing an exception differs from passing a parameter or calling a virtual function.

# Item_13: Catch exceptions by reference.

# Item_14: Use exception specifications judiciously.

# Item_15: Understand the costs of exception handling.

# Item_16: Remember the 80-20 rule.

# Item_17: Consider using lazy evaluation.

# Item_18: Amortize the cost of expected computations.

# Item_19: Understand the origin of temporary objects.

# Item_20: Facilitate the return value optimization.

# Item_21: Overload to avoid implicit type conversions.

# Item_22: Consider using op= instead of stand-alone op.

# Item_23: Consider alternative libraries.

# Item_24: Understand the costs of virtual functions, multiple inheritance, virtual base classes, and RTTI.

# Item_25: Virtualizing constructors and non-member functions.

# Item_26: Limiting the number of objects of a class.

# Item_27: Requiring or prohibiting heap-based objects.

# Item_28: Smart pointers.

# Item_29: Reference counting.

# Item_30: Proxy classes.

# Item_31: Making functions virtual with respect to more than one object.

# Item_32: Program in the future tense.

# Item_33: Make non-leaf classes abstract.

# Item_34: Understand how to combine C++ and C in the same program.

# Item_35: Familiarize yourself with the language standard.